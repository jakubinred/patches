Binary files a/.DS_Store and b/.DS_Store differ
diff -ruN a/LICENSE.txt b/LICENSE.txt
--- a/LICENSE.txt	1970-01-01 01:00:00.000000000 +0100
+++ b/LICENSE.txt	2016-11-17 00:57:05.000000000 +0100
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -ruN a/README.md b/README.md
--- a/README.md	1970-01-01 01:00:00.000000000 +0100
+++ b/README.md	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,103 @@
+# Entity Embed Module
+
+[Entity Embed](https://www.drupal.org/project/entity_embed) module
+allows any entity to be embedded using a text editor.
+
+## Requirements
+
+* Drupal 8
+* [Embed](https://www.drupal.org/project/embed) module
+
+## Installation
+
+Entity Embed can be installed via the
+[standard Drupal installation process](http://drupal.org/node/895232).
+
+## Configuration
+
+* Install and enable [Embed](https://www.drupal.org/project/embed) module.
+* Install and enable [Entity Embed](https://www.drupal.org/project/entity_embed)
+  module.
+* Go to the 'Text formats and editors' configuration page: `/admin/config/content/formats`,
+  and for each text format/editor combo where you want to embed entities,
+  do the following:
+  * Enable the "Display embedded entities" filter for the desired text formats
+    on the Text Formats configuration page.
+  * Drag and drop the 'E' button into the Active toolbar.
+  * If the text format uses the 'Limit allowed HTML tags and correct
+    faulty HTML' filter, ensure the necessary tags and attributes were
+    automatically whitelisted:
+    ```<drupal-entity data-entity-type data-entity-uuid data-view-mode data-entity-embed-display data-entity-embed-display-settings data-align data-caption data-embed-button data-langcode alt title>```
+    appears in the 'Allowed HTML tags' setting.
+    *Warning: If you were using the module in very early pre-alpha
+    stages you might need to add `data-entity-id` to the list of allowed
+    attributes. Similarly, if you have been using the module in pre-beta stages,
+    you need to white-list the `data-entity-embed-settings` attribute.*
+  * If you're using both the 'Align images' and 'Caption images' filters make
+    sure the 'Align images' filter is run before the 'Caption images' filter in
+    the **Filter processing order** section. (Explanation: Due to the
+    implementation details of the two filters it is important to execute them in
+    the right sequence in order to obtain a sensible final markup. In practice
+    this means that the alignment filter has to be run before the caption
+    filter, otherwise the alignment class will appear inside the <figure> tag
+    (instead of appearing on it) the caption filter produces.)
+
+## Usage
+
+* For example, create a new *Article* content.
+* Click on the 'E' button in the text editor.
+* Enter part of the title of the entity you're looking for and select
+  one of the search results.
+* If the entity you select is a node entity, for **Display as** you can choose
+  one of the following options:
+  * Entity ID
+  * Label
+  * Full content
+  * RSS
+  * Search index
+  * Search result highlighting input
+  * Teaser
+* The last five options depend on the view modes you have on the entity.
+* Optionally, choose to align left, center or right.
+**Rendered Entity** was available before but now the view modes are
+ available as entity embed display plugins.
+
+## Embedding entities without WYSIWYG
+
+Users should be embedding entities using the CKEditor WYSIWYG button as
+described above. This section is more technical about the HTML markup
+that is used to embed the actual entity.
+
+### Example:
+```html
+<drupal-entity data-entity-type="node" data-entity-uuid="07bf3a2e-1941-4a44-9b02-2d1d7a41ec0e" data-entity-embed-display="entity_reference:entity_reference_entity_view" data-entity-embed-display-settings='{"view_mode":"teaser"}' />
+```
+
+## Entity Embed Display Plugins
+
+Embedding entities uses an Entity Embed Display plugin, provided in the
+`data-entity-embed-display` attribute. By default we provide four
+different Entity Embed Display plugins out of the box:
+
+- entity_reference:_formatter_id_: Renders the entity using a specific
+  Entity Reference field formatter.
+- entity_reference:_entity_reference_label_: Renders the entity using
+  the "Label" formatter.
+- file:_formatter_id_: Renders the entity using a specific File field
+  formatter. This will only work if the entity is a file entity type.
+- image:_formatter_id_: Renders the entity using a specific Image field
+  formatter. This will only work if the entity is a file entity type,
+  and the file is an image.  For the alt and title text to save, the `alt`
+  and `title` attributes must be allowed on the `<drupal-entity>` HTML tag
+  in the "Allowed HTML tags" for text formats that have the "Limit allowed
+  HTML tags and correct faulty HTML" filter enabled.
+
+Configuration for the Entity Embed Display plugin can be provided by
+using a `data-entity-embed-display-settings` attribute, which contains a
+JSON-encoded array value. Note that care must be used to use single
+quotes around the attribute value since JSON-encoded arrays typically
+contain double quotes.
+
+The above examples render the entity using the
+_entity_reference_entity_view_ formatter from the Entity Reference
+module, using the _teaser_ view mode.
diff -ruN a/composer.json b/composer.json
--- a/composer.json	1970-01-01 01:00:00.000000000 +0100
+++ b/composer.json	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,12 @@
+{
+    "name": "drupal/entity_embed",
+    "description": "Allows any entity to be embedded within a text area using a WYSIWYG editor.",
+    "type": "drupal-module",
+    "license": "GPL-2.0-or-later",
+    "require": {
+        "drupal/embed": "^1.5"
+    },
+    "require-dev": {
+        "drupal/entity_browser": "^2.2"
+    }
+}
diff -ruN a/config/install/entity_embed.settings.yml b/config/install/entity_embed.settings.yml
--- a/config/install/entity_embed.settings.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/config/install/entity_embed.settings.yml	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1 @@
+rendered_entity_mode: false
diff -ruN a/config/optional/embed.button.node.yml b/config/optional/embed.button.node.yml
--- a/config/optional/embed.button.node.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/config/optional/embed.button.node.yml	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,14 @@
+langcode: en
+status: true
+dependencies:
+  module:
+    - entity_embed
+    - node
+label: Node
+id: node
+type_id: entity
+type_settings:
+  entity_type: node
+  bundles: {  }
+  display_plugins: {  }
+icon_uuid: null
diff -ruN a/config/schema/entity_embed.schema.yml b/config/schema/entity_embed.schema.yml
--- a/config/schema/entity_embed.schema.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/config/schema/entity_embed.schema.yml	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,39 @@
+# Schema for the configuration files of the Entity Embed module.
+
+embed.embed_type_settings.entity:
+  type: mapping
+  label: 'Schema for the entity embed type additions to an embed button entity'
+  mapping:
+    entity_type:
+      type: string
+      label: 'Entity type'
+    bundles:
+      type: sequence
+      label: 'Bundles'
+      sequence:
+        type: string
+        label: 'Bundle'
+    display_plugins:
+      type: sequence
+      label: 'Allowed Entity Embed Display plugins'
+      sequence:
+        type: string
+        label: 'Entity Embed Display plugin'
+    entity_browser:
+      type: string
+      label: 'Entity browser'
+    entity_browser_settings:
+      type: mapping
+      label: 'Entity browser settings'
+      mapping:
+        display_review:
+          type: boolean
+          label: 'Display review step'
+
+entity_embed.settings:
+  type: config_object
+  label: 'Entity embed settings'
+  mapping:
+    rendered_entity_mode:
+      type: boolean
+      label: 'Rendered entity mode'
diff -ruN a/css/entity_embed.dialog.css b/css/entity_embed.dialog.css
--- a/css/entity_embed.dialog.css	1970-01-01 01:00:00.000000000 +0100
+++ b/css/entity_embed.dialog.css	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,30 @@
+/**
+ * @file
+ * Styles for Entity Browser's modal windows.
+ */
+
+.entity-embed-dialog iframe {
+  border: none;
+}
+
+.ui-dialog--narrow.entity-select-dialog {
+  max-width: 1200px;
+}
+
+@media screen and (min-width: 768px) {
+  .ui-dialog--narrow.entity-select-dialog .entity-embed-dialog-step--select {
+    min-width: 730px; /* 95% */
+  }
+}
+
+@media screen and (min-width: 1000px) {
+  .ui-dialog--narrow.entity-select-dialog .entity-embed-dialog-step--select {
+    min-width: 950px; /* 95% */
+  }
+}
+
+@media screen and (min-width: 1200px) {
+  .ui-dialog--narrow.entity-select-dialog .entity-embed-dialog-step--select {
+    min-width: 1140px; /* 95% */
+  }
+}
diff -ruN a/css/entity_embed.editor.css b/css/entity_embed.editor.css
--- a/css/entity_embed.editor.css	1970-01-01 01:00:00.000000000 +0100
+++ b/css/entity_embed.editor.css	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,15 @@
+/**
+ * @file
+ * Styles for CKEditor iframe.
+ */
+
+drupal-entity {
+  display: inline-block;
+}
+drupal-entity[data-align=left],
+drupal-entity[data-align=right] {
+  display: inline;
+}
+drupal-entity[data-align=center] {
+  display: flex;
+}
diff -ruN a/css/entity_embed.filter.caption.css b/css/entity_embed.filter.caption.css
--- a/css/entity_embed.filter.caption.css	1970-01-01 01:00:00.000000000 +0100
+++ b/css/entity_embed.filter.caption.css	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,10 @@
+/**
+ * @file
+ * Caption filter: default styling for displaying Entity Embed captions.
+ */
+
+.caption .media .field,
+.caption .media .field * {
+  float: none;
+  margin: unset;
+}
diff -ruN a/entity_embed.api.php b/entity_embed.api.php
--- a/entity_embed.api.php	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.api.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,130 @@
+<?php
+
+/**
+ * @file
+ * Hooks provided by the Entity Embed module.
+ */
+
+/**
+ * @addtogroup hooks
+ * @{
+ */
+
+/**
+ * Alter the Entity Embed Display plugin definitions.
+ *
+ * @param array &$info
+ *   An associative array containing the plugin definitions keyed by plugin ID.
+ */
+function hook_entity_embed_display_plugins_alter(array &$info) {
+
+}
+
+/**
+ * Alter the Entity Embed Display plugin definitions for a given context.
+ *
+ * Usually used to remove certain Entity Embed Display plugins for specific
+ * entities.
+ *
+ * @param array &$definitions
+ *   Remove options from this list if they should not be available for the given
+ *   context.
+ * @param array $contexts
+ *   The provided context, typically an entity.
+ */
+function hook_entity_embed_display_plugins_for_context_alter(array &$definitions, array $contexts) {
+  // Do nothing if no entity is provided.
+  if (!isset($contexts['entity'])) {
+    return;
+  }
+  $entity = $contexts['entity'];
+
+  // For video and audio files, limit the available options to the media player.
+  if ($entity instanceof \Drupal\file\FileInterface && in_array($entity->bundle(), ['audio', 'video'])) {
+    $definitions = array_intersect_key($definitions, array_flip(['file:jwplayer_formatter']));
+  }
+
+  // For images, use the image formatter.
+  if ($entity instanceof \Drupal\file\FileInterface && in_array($entity->bundle(), ['image'])) {
+    $definitions = array_intersect_key($definitions, array_flip(['image:image']));
+  }
+
+  // For nodes, use the default option.
+  if ($entity instanceof \Drupal\node\NodeInterface) {
+    $definitions = array_intersect_key($definitions, array_flip(['entity_reference:entity_reference_entity_view']));
+  }
+}
+
+/**
+ * Alter the context of an embedded entity before it is rendered.
+ *
+ * @param array &$context
+ *   The context array.
+ * @param \Drupal\Core\Entity\EntityInterface $entity
+ *   The entity object.
+ */
+function hook_entity_embed_context_alter(array &$context, \Drupal\Core\Entity\EntityInterface $entity) {
+  if (isset($context['overrides']) && is_array($context['overrides'])) {
+    foreach ($context['overrides'] as $key => $value) {
+      $entity->key = $value;
+    }
+  }
+}
+
+/**
+ * Alter the context of a particular embedded entity type before it is rendered.
+ *
+ * @param array &$context
+ *   The context array.
+ * @param \Drupal\Core\Entity\EntityInterface $entity
+ *   The entity object.
+ */
+function hook_ENTITY_TYPE_embed_context_alter(array &$context, \Drupal\Core\Entity\EntityInterface $entity) {
+  if (isset($context['overrides']) && is_array($context['overrides'])) {
+    foreach ($context['overrides'] as $key => $value) {
+      $entity->key = $value;
+    }
+  }
+}
+
+/**
+ * Alter the results of an embedded entity build array.
+ *
+ * This hook is called after the content has been assembled in a structured
+ * array and may be used for doing processing which requires that the complete
+ * block content structure has been built.
+ *
+ * @param array &$build
+ *   A renderable array representing the embedded entity content.
+ * @param \Drupal\Core\Entity\EntityInterface $entity
+ *   The embedded entity object.
+ * @param array $context
+ *   The context array.
+ */
+function hook_entity_embed_alter(array &$build, \Drupal\Core\Entity\EntityInterface $entity, array &$context) {
+  // Remove the contextual links.
+  if (isset($build['#contextual_links'])) {
+    unset($build['#contextual_links']);
+  }
+}
+
+/**
+ * Alter the results of the particular embedded entity type build array.
+ *
+ * @param array &$build
+ *   A renderable array representing the embedded entity content.
+ * @param \Drupal\Core\Entity\EntityInterface $entity
+ *   The embedded entity object.
+ * @param array $context
+ *   The context array.
+ */
+function hook_ENTITY_TYPE_embed_alter(array &$build, \Drupal\Core\Entity\EntityInterface $entity, array &$context) {
+  // Remove the contextual links.
+  if (isset($build['#contextual_links'])) {
+    unset($build['#contextual_links']);
+  }
+}
+
+/**
+ * @} End of "addtogroup hooks".
+ */
diff -ruN a/entity_embed.info.yml b/entity_embed.info.yml
--- a/entity_embed.info.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.info.yml	2023-06-08 22:56:25.000000000 +0200
@@ -0,0 +1,15 @@
+name: Entity Embed
+type: module
+description: 'Allows entities to be embedded using a text editor.'
+core_version_requirement: ^9.3 || ^10
+package: Filters
+dependencies:
+  - drupal:editor
+  - embed:embed
+  - drupal:filter
+  - drupal:system
+
+# Information added by Drupal.org packaging script on 2022-10-20
+version: '8.x-1.3'
+project: 'entity_embed'
+datestamp: 1666275544
diff -ruN a/entity_embed.install b/entity_embed.install
--- a/entity_embed.install	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.install	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,101 @@
+<?php
+
+/**
+ * @file
+ * Contains install and update functions for Entity Embed.
+ */
+
+use Drupal\Core\Entity\ContentEntityType;
+use Drupal\Core\StringTranslation\TranslatableMarkup;
+use Drupal\embed\Entity\EmbedButton;
+use Drupal\Core\Utility\UpdateException;
+
+/**
+ * Convert entity embed buttons to embed buttons.
+ *
+ * @todo Can we reuse the existing UUID and save before deleting the old button?
+ */
+function entity_embed_update_8001() {
+  $config_factory = \Drupal::configFactory();
+
+  foreach ($config_factory->listAll('entity_embed.embed_button.') as $config_name) {
+    $old_embed_button = $config_factory->getEditable($config_name);
+    $values = $old_embed_button->getRawData();
+
+    if (EmbedButton::load($values['id'])) {
+      throw new UpdateException('Unable to convert entity_embed.embed_button.' . $values['id'] . ' to embed.button.' . $values['id'] . ' since the latter already exists.');
+    }
+
+    // Move some data around.
+    $values['type_id'] = 'entity';
+    $values['type_settings'] = [
+      'entity_type' => $values['entity_type'],
+      'bundles' => array_keys(array_filter($values['entity_type_bundles'])),
+      'display_plugins' => array_keys(array_filter($values['display_plugins'])),
+    ];
+    $values['icon_uuid'] = $values['button_icon_uuid'];
+    unset($values['entity_type']);
+    unset($values['entity_type_bundles']);
+    unset($values['display_plugins']);
+    unset($values['button_icon_uuid']);
+
+    // Save the new embed button and delete the old one.
+    $embed_button = EmbedButton::create($values);
+    $embed_button->save();
+    $old_embed_button->delete();
+  }
+}
+
+/**
+ * Updates the default mode settings.
+ */
+function entity_embed_update_8002() {
+  \Drupal::configFactory()
+    ->getEditable('entity_embed.settings')
+    ->set('rendered_entity_mode', TRUE)
+    ->save();
+}
+
+/**
+ * Updates allowed HTML for all filter configs that have an Entity Embed button.
+ */
+function entity_embed_update_8003() {
+  $buttons = \Drupal::entityTypeManager()->getStorage('embed_button')->loadMultiple();
+  $filter_formats_with_embed_button = [];
+
+  // Get filter formats from editors with entity embed button.
+  foreach (\Drupal::entityTypeManager()->getStorage('editor')->loadMultiple() as $editor) {
+    foreach (new RecursiveIteratorIterator(new RecursiveArrayIterator($editor->getSettings())) as $settings_value) {
+      foreach ($buttons as $button) {
+        if ($settings_value == $button->id()) {
+          $filter_formats_with_embed_button[] = $editor->getFilterFormat();
+        }
+      }
+    }
+  }
+  foreach ($filter_formats_with_embed_button as $filter_format) {
+    foreach ($filter_format->filters()->getAll() as $filter) {
+      if (isset($filter->getConfiguration()['settings']['allowed_html'])) {
+        $allowed_html = $filter->getConfiguration()['settings']['allowed_html'];
+        if (strpos($allowed_html, 'data-entity-embed-settings')) {
+          $allowed_html = str_replace('data-entity-embed-settings', 'data-entity-embed-settings data-entity-embed-display-settings', $allowed_html);
+          $filter_format->setFilterConfig($filter->getPluginId(), ['settings' => ['allowed_html' => $allowed_html]]);
+          $filter_format->save();
+        }
+      }
+    }
+  }
+}
+
+/**
+ * Adds new content entity type to remove dependency on node module.
+ */
+function entity_embed_update_8004() {
+  \Drupal::entityDefinitionUpdateManager()->installEntityType(new ContentEntityType([
+    'id' => 'entity_embed_fake_entity',
+    'label' => new TranslatableMarkup('Fake entity type'),
+    'handlers' => [
+      'storage' => 'Drupal\\Core\\Entity\\ContentEntityNullStorage',
+    ],
+  ]));
+}
diff -ruN a/entity_embed.libraries.yml b/entity_embed.libraries.yml
--- a/entity_embed.libraries.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.libraries.yml	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,36 @@
+drupal.entity_embed.dialog:
+  version: VERSION
+  js:
+    js/entity_embed.dialog.js: {}
+  css:
+    theme:
+      css/entity_embed.dialog.css: {}
+  dependencies:
+    - core/drupal
+    - core/jquery
+    - core/once
+
+caption:
+  version: VERSION
+  css:
+    component:
+      css/entity_embed.filter.caption.css: {}
+  dependencies:
+    - filter/caption
+
+# CKEditor 5
+entity_embed:
+  js:
+    js/build/drupalentity.js: { minified: true }
+  dependencies:
+    - core/ckeditor5
+    - core/drupal
+
+admin.entity_embed:
+  js:
+    js/entity_embed.set_dynamic_icons.js: {}
+  dependencies:
+    - core/drupal
+    - core/jquery
+    - core/once
+    - core/drupalSettings
diff -ruN a/entity_embed.module b/entity_embed.module
--- a/entity_embed.module	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.module	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,361 @@
+<?php
+
+/**
+ * @file
+ * Framework for allowing entities to be embedded in CKEditor.
+ */
+
+use Drupal\ckeditor5\Plugin\CKEditor5PluginDefinition;
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Cache\Cache;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Component\Serialization\Json;
+use Drupal\Core\Routing\RouteMatchInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Field\FieldItemListInterface;
+use Drupal\Core\Entity\ContentEntityInterface;
+use Drupal\embed\EmbedButtonInterface;
+use Drupal\embed\Entity\EmbedButton;
+use Drupal\entity_embed\Event\EmbedButtonEvent;
+
+/**
+ * Implements hook_help().
+ */
+function entity_embed_help($route_name, RouteMatchInterface $route_match) {
+  switch ($route_name) {
+    case 'help.page.entity_embed':
+      $output = '';
+      $output .= '<h3>' . t('About') . '</h3>';
+      $output .= '<p>' . t('The Entity Embed module allows entities to be embedded in formatted text.') . '</p>';
+      $output .= '<h3>' . t('Uses') . '</h3>';
+      $output .= '<dl>';
+      $output .= '<dt>' . t('Embedding media') . '</dt>';
+      $output .= '<dd>' . t('This module, and the text filter that it provides along with the CKEditor integration, is especially suited to allow content authors to embed media in their textual content: images, video, and so on.') . '</dd>';
+      $output .= '<dt>' . t('Embedding arbitrary content') . '</dt>';
+      $output .= '<dd>' . t('As mentioned above, this module is especially helpful for embedding media in textual content, but it is not necessarily restricted to that; it allows <em>any</em> entity to be embedded. On an e-commerce site, you may want to embed products, on a company blog you may want to embed past projects, and so on.') . '</dd>';
+      $output .= '</dl>';
+      return $output;
+  }
+}
+
+/**
+ * Implements hook_theme().
+ */
+function entity_embed_theme() {
+  return [
+    'entity_embed_container' => [
+      'render element' => 'element',
+    ],
+  ];
+}
+
+/**
+ * Prepares variables for entity embed container templates.
+ *
+ * Default template: entity-embed-container.html.twig.
+ *
+ * @param array $variables
+ *   An associative array containing:
+ *   - element: An associative array containing the properties of the element.
+ *     Properties used: #attributes, #children.
+ */
+function template_preprocess_entity_embed_container(array &$variables) {
+  $variables['element'] += ['#attributes' => []];
+  $variables['attributes'] = $variables['element']['#attributes'];
+  $variables['children'] = $variables['element']['#children'];
+
+  // Ensure the display settings get converted to a JSON string again.
+  if (isset($variables['attributes']['data-entity-embed-display-settings']) && is_array($variables['attributes']['data-entity-embed-display-settings'])) {
+    $variables['attributes']['data-entity-embed-display-settings'] = Json::encode($variables['attributes']['data-entity-embed-display-settings']);
+  }
+}
+
+/**
+ * Implements hook_entity_embed_display_plugins_alter().
+ *
+ * Implementation on behalf of the file module.
+ */
+function file_entity_embed_display_plugins_alter(array &$plugins) {
+  // The RSS enclosure field formatter is not usable for Entity Embed.
+  unset($plugins['file:file_rss_enclosure']);
+}
+
+/**
+ * Implements hook_entity_embed_display_plugins_alter().
+ *
+ * Implementation on behalf of the taxonomy module.
+ */
+function taxonomy_entity_embed_display_plugins_alter(array &$plugins) {
+  // The RSS category field formatter is not usable for Entity Embed.
+  unset($plugins['entity_reference:entity_reference_rss_category']);
+}
+
+/**
+ * Implements hook_entity_embed_display_plugins_for_context_alter().
+ *
+ * The 'Rendered entity' formatter can not be used for files unless the
+ * file_entity module is available.
+ *
+ * @see https://www.drupal.org/node/2468387
+ *
+ * @todo Remove when https://www.drupal.org/node/2567919 is fixed in core.
+ */
+function entity_embed_entity_embed_display_plugins_for_context_alter(array &$definitions, array $context) {
+  if ($context['entity_type'] === 'file' && !\Drupal::moduleHandler()->moduleExists('file_entity')) {
+    unset($definitions['entity_reference:entity_reference_entity_view']);
+  }
+}
+
+/**
+ * Implements hook_form_FORM_ID_alter().
+ */
+function entity_embed_form_filter_format_edit_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
+  // Add an additional validate callback so we can ensure the order of filters
+  // is correct.
+  $form['#validate'][] = 'entity_embed_filter_format_edit_form_validate';
+}
+
+/**
+ * Implements hook_form_FORM_ID_alter().
+ */
+function entity_embed_form_filter_format_add_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
+  // Add an additional validate callback so we can ensure the order of filters
+  // is correct.
+  $form['#validate'][] = 'entity_embed_filter_format_edit_form_validate';
+}
+
+/**
+ * Validate callback to ensure filter order and allowed_html are compatible.
+ */
+function entity_embed_filter_format_edit_form_validate($form, FormStateInterface $form_state) {
+  // This validate handler is not applicable when using the 'Configure' button.
+  if ($form_state->getTriggeringElement()['#name'] === 'editor_configure') {
+    return;
+  }
+
+  $allowed_html_path = [
+    'filters',
+    'filter_html',
+    'settings',
+    'allowed_html',
+  ];
+
+  $button_group_path = [
+    'editor',
+    'settings',
+    'toolbar',
+    'button_groups',
+  ];
+
+  $filter_html_settings_path = [
+    'filters',
+    'filter_html',
+    'settings',
+  ];
+
+  $filter_html_enabled = $form_state->getValue([
+    'filters',
+    'filter_html',
+    'status',
+  ]);
+
+  $entity_embed_enabled = $form_state->getValue([
+    'filters',
+    'entity_embed',
+    'status',
+  ]);
+
+  if ($entity_embed_enabled && $filter_html_enabled && $form_state->getValue($allowed_html_path)) {
+    if ($button_groups = $form_state->getValue($button_group_path)) {
+      $buttons = [];
+      $button_groups = json_decode($button_groups, TRUE);
+      if (!empty($button_groups[0])) {
+        foreach ($button_groups[0] as $button_group) {
+          foreach ($button_group['items'] as $item) {
+            $buttons[] = $item;
+          }
+        }
+      }
+
+      /** @var \Drupal\filter\Entity\FilterFormat $filter_format */
+      $filter_format = $form_state->getFormObject()->getEntity();
+
+      $filter_html = $filter_format->filters()->get('filter_html');
+      $filter_html->setConfiguration(['settings' => $form_state->getValue($filter_html_settings_path)]);
+      $restrictions = $filter_html->getHTMLRestrictions();
+      $allowed = $restrictions['allowed'];
+
+      $embeds = \Drupal::entityTypeManager()
+        ->getStorage('embed_button')
+        ->loadMultiple($buttons);
+
+      /** @var \Drupal\embed\Entity\EmbedButton $embed */
+      foreach ($embeds as $embed) {
+        if ($embed->getTypeId() !== 'entity') {
+          continue;
+        }
+        // Require `<drupal-entity>` HTML tag if filter_html is enabled.
+        if (!isset($allowed['drupal-entity'])) {
+          $form_state->setError($form['filters']['settings']['filter_html']['allowed_html'], t('The %embed button requires <code>&lt;drupal-entity&gt;</code> among the allowed HTML tags.', [
+            '%embed' => $embed->label(),
+          ]));
+          break;
+        }
+        else {
+          $required_attributes = [
+            'data-entity-type',
+            'data-entity-uuid',
+            'data-entity-embed-display',
+            'data-entity-embed-display-settings',
+            'data-align',
+            'data-caption',
+            'data-embed-button',
+            'alt',
+            'title',
+          ];
+
+          // If there are no attributes, the allowed item is set to FALSE,
+          // otherwise, it is set to an array.
+          if ($allowed['drupal-entity'] === FALSE) {
+            $missing_attributes = $required_attributes;
+          }
+          else {
+            // If any of the attributes on the drupal-entity tag use wildcards,
+            // iterate through and replace them with matching required
+            // attributes.
+            $wildcards = preg_grep('/\*/', array_keys($allowed['drupal-entity']));
+            if (!empty($wildcards)) {
+              foreach ($wildcards as $wildcard) {
+                $pattern = str_replace('*', '(.*)', $wildcard);
+                $matches = preg_grep('/' . $pattern . '/', $required_attributes);
+                foreach ($matches as $match) {
+                  $allowed['drupal-entity'][$match] = 1;
+                }
+                unset($allowed['drupal-entity'][$wildcard]);
+              }
+            }
+            $missing_attributes = array_diff($required_attributes, array_keys($allowed['drupal-entity']));
+          }
+
+          if ($missing_attributes) {
+            $form_state->setError($form['filters']['settings']['filter_html']['allowed_html'], t('The <code>&lt;drupal-entity&gt;</code> tag in the allowed HTML tags is missing the following attributes: <code>%list</code>.', [
+              '%list' => implode(', ', $missing_attributes),
+            ]));
+            break;
+          }
+        }
+      }
+    }
+  }
+
+  $filters = $form_state->getValue('filters');
+
+  $get_filter_label = function ($filter_plugin_id) use ($form) {
+    return (string) $form['filters']['order'][$filter_plugin_id]['filter']['#markup'];
+  };
+
+  // The "entity_embed" filter must run after "filter_align", "filter_caption",
+  // and "filter_html_image_secure".
+  if ($entity_embed_enabled) {
+    $precedents = [
+      'filter_align',
+      'filter_caption',
+      'filter_html_image_secure',
+    ];
+
+    $error_filters = [];
+    foreach ($precedents as $filter_name) {
+
+      // A filter that should run before entity embed filter.
+      $precedent = $filters[$filter_name];
+
+      if (empty($precedent['status']) || !isset($precedent['weight'])) {
+        continue;
+      }
+
+      if ($precedent['weight'] >= $filters['entity_embed']['weight']) {
+        $error_filters[$filter_name] = $get_filter_label($filter_name);
+      }
+    }
+
+    if (!empty($error_filters)) {
+      $singular = 'The %entity-embed-filter-label filter needs to be placed after the %filter filter.';
+      $plural = 'The %entity-embed-filter-label filter needs to be placed after the following filters: %filters.';
+      $error_message = \Drupal::translation()->formatPlural(count($error_filters), $singular, $plural, [
+        '%entity-embed-filter-label' => $get_filter_label('entity_embed'),
+        '%filter' => reset($error_filters),
+        '%filters' => implode(', ', $error_filters),
+      ]);
+
+      $form_state->setErrorByName('filters', $error_message);
+    }
+  }
+}
+
+/**
+ * Implements hook_field_widget_single_element_form_alter().
+ */
+function entity_embed_field_widget_single_element_form_alter(&$element, FormStateInterface $form_state, $context) {
+  // Add a `data-entity_embed-host-entity-langcode` attribute so that
+  // entity_embed's JavaScript can pass the host entity's language to
+  // EntityEmbedDialog, allowing it to present entities in the same language.
+  if (isset($element['#type']) && $element['#type'] === 'text_format') {
+    /** @var FieldItemListInterface $items */
+    $items = $context['items'];
+    $element['#attributes']['data-entity_embed-host-entity-langcode'] = $items->getEntity()->language()->getId();
+  }
+}
+
+/**
+ * Implements hook_ENTITY_TYPE_presave().
+ */
+function entity_embed_embed_button_presave(EntityInterface $entity) {
+  // Invalidate the CKEditor 5 plugin cache, so new toolbar items will appear
+  // based on which Embed Buttons are configured.
+  /** @var \Drupal\ckeditor5\Plugin\CKEditor5PluginManagerInterface $ckeditor5_plugin_manager */
+  if (\Drupal::hasService('plugin.manager.ckeditor5.plugin')) {
+    $ckeditor5_plugin_manager = \Drupal::service('plugin.manager.ckeditor5.plugin');
+    $ckeditor5_plugin_manager->clearCachedDefinitions();
+    // @see entity_embed_library_info_alter()
+    Cache::invalidateTags(['library_info']);
+  }
+}
+
+/**
+ * Implements hook_library_info_alter().
+ */
+function entity_embed_library_info_alter(&$libraries, $extension) {
+  // Create the drupalSettings dynamically based on embed buttons for the
+  // admin library.
+  if ($extension === 'entity_embed' && isset($libraries['admin.entity_embed'])) {
+    $embed_buttons = \Drupal::entityTypeManager()
+      ->getStorage('embed_button')
+      ->loadMultiple();
+    foreach ($embed_buttons as $embed_button) {
+      $libraries['admin.entity_embed']['drupalSettings']['embedButtons'][$embed_button->id()] = [
+        'id' => $embed_button->id(),
+        'icon' => $embed_button->getIconUrl(),
+      ];
+
+    }
+    $libraries['admin.entity_embed']['drupalSettings']['modulePath'] = \Drupal::service('extension.list.module')->getPath('entity_embed');
+  }
+}
+
+/**
+ * Implements hook_ckeditor4to5upgrade_plugin_info_alter().
+ */
+function entity_embed_ckeditor4to5upgrade_plugin_info_alter(array &$plugin_definitions): void {
+  // Get the user set buttons and add them to the entity embed plugin definition
+  $buttons = [];
+  $embed_buttons = \Drupal::entityTypeManager()
+    ->getStorage('embed_button')
+    ->loadMultiple();
+  foreach ($embed_buttons as $embed_button) {
+    $buttons[] = $embed_button->id();
+  }
+
+  if ($buttons) {
+    $plugin_definitions['entity_embed']["cke4_buttons"] = $buttons;
+  }
+}
diff -ruN a/entity_embed.routing.yml b/entity_embed.routing.yml
--- a/entity_embed.routing.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.routing.yml	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,7 @@
+entity_embed.dialog:
+  path: '/entity-embed/dialog/{editor}/{embed_button}'
+  defaults:
+    _form: '\Drupal\entity_embed\Form\EntityEmbedDialog'
+    _title: 'Embed entity'
+  requirements:
+    _embed_button_editor_access: 'TRUE'
diff -ruN a/entity_embed.services.yml b/entity_embed.services.yml
--- a/entity_embed.services.yml	1970-01-01 01:00:00.000000000 +0100
+++ b/entity_embed.services.yml	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,12 @@
+services:
+  plugin.manager.entity_embed.display:
+    class: Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+    arguments: ['@container.namespaces', '@cache.discovery', '@module_handler']
+  entity_embed.twig.entity_embed_twig_extension:
+    class: Drupal\entity_embed\Twig\EntityEmbedTwigExtension
+    arguments: ['@entity_type.manager', '@entity_embed.builder']
+    tags:
+      - { name: twig.extension }
+  entity_embed.builder:
+    class: Drupal\entity_embed\EntityEmbedBuilder
+    arguments: ['@module_handler', '@plugin.manager.entity_embed.display']
diff -ruN a/js/build/drupalentity.js b/js/build/drupalentity.js
--- a/js/build/drupalentity.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/build/drupalentity.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1 @@
+!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.CKEditor5=e():(t.CKEditor5=t.CKEditor5||{},t.CKEditor5.drupalentity=e())}(self,(()=>(()=>{var t={"ckeditor5/src/core.js":(t,e,i)=>{t.exports=i("dll-reference CKEditor5.dll")("./src/core.js")},"ckeditor5/src/ui.js":(t,e,i)=>{t.exports=i("dll-reference CKEditor5.dll")("./src/ui.js")},"ckeditor5/src/widget.js":(t,e,i)=>{t.exports=i("dll-reference CKEditor5.dll")("./src/widget.js")},"dll-reference CKEditor5.dll":t=>{"use strict";t.exports=CKEditor5.dll}},e={};function i(r){var n=e[r];if(void 0!==n)return n.exports;var o=e[r]={exports:{}};return t[r](o,o.exports,i),o.exports}i.d=(t,e)=>{for(var r in e)i.o(e,r)&&!i.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var r={};return(()=>{"use strict";i.d(r,{default:()=>u});var t=i("ckeditor5/src/core.js"),e=i("ckeditor5/src/widget.js");class n extends t.Command{execute(t){const{model:e}=this.editor,i=this.editor.plugins.get("EntityEmbedEditing"),r=Object.entries(i.attrs).reduce(((t,[e,i])=>(t[i]=e,t)),{}),n=Object.keys(t).reduce(((e,i)=>(r[i]&&(e[r[i]]=t[i]),e)),{});e.change((t=>{e.insertContent(function(t,e){return t.createElement("drupalEntity",e)}(t,n))}))}refresh(){const t=this.editor.model,e=t.document.selection,i=t.schema.findAllowedParent(e.getFirstPosition(),"drupalEntity");this.isEnabled=null!==i}}class o extends t.Plugin{static get requires(){return[e.Widget]}init(){this.attrs={alt:"alt",title:"title",dataCaption:"data-caption",dataAlign:"data-align",drupalEntityLangCode:"data-langcode",drupalEntityEntityType:"data-entity-type",drupalEntityEntityUuid:"data-entity-uuid",drupalEntityEmbedButton:"data-embed-button",drupalEntityEmbedDisplay:"data-entity-embed-display",drupalEntityEmbedDisplaySettings:"data-entity-embed-display-settings"};const t=this.editor.config.get("entityEmbed");t&&(this.options=t,this.labelError=Drupal.t("Preview failed"),this.previewError=`\n      <p>${Drupal.t("An error occurred while trying to preview the embedded content. Please save your work and reload this page.")}<p>\n    `,this._defineSchema(),this._defineConverters(),this.editor.commands.add("insertEntityEmbed",new n(this.editor)))}_defineSchema(){this.editor.model.schema.register("drupalEntity",{isObject:!0,isContent:!0,isBlock:!0,allowWhere:"$block",allowAttributes:Object.keys(this.attrs)}),this.editor.editing.view.domConverter.blockElements.push("drupal-entity")}_defineConverters(){const{conversion:t}=this.editor;t.for("upcast").elementToElement({model:"drupalEntity",view:{name:"drupal-entity"}}),t.for("dataDowncast").elementToElement({model:"drupalEntity",view:{name:"drupal-entity"}}),t.for("editingDowncast").elementToElement({model:"drupalEntity",view:(t,{writer:i})=>{const r=i.createContainerElement("figure",{class:"drupal-entity"});return i.setCustomProperty("drupalEntity",!0,r),(0,e.toWidget)(r,i,{label:Drupal.t("Entity Embed widget")})}}).add((t=>(t.on("attribute:drupalEntityEntityUuid:drupalEntity",((t,e,i)=>{const r=i.writer,n=e.item,o=i.mapper.toViewElement(e.item);let a=this._getPreviewContainer(o.getChildren());if(a){if("ready"!==a.getAttribute("data-drupal-entity-preview"))return;r.setAttribute("data-drupal-entity-preview","loading",a)}else a=r.createRawElement("div",{"data-drupal-entity-preview":"loading"}),r.insert(r.createPositionAt(o,0),a);this._loadPreview(n).then((({label:t,preview:e})=>{a&&this.editor.editing.view.change((i=>{const r=i.createRawElement("div",{"data-drupal-entity-preview":"ready","aria-label":t},(t=>{t.innerHTML=e}));i.insert(i.createPositionBefore(a),r),i.remove(a)}))}))})),t))),Object.keys(this.attrs).forEach((e=>{const i={model:{key:e,name:"drupalEntity"},view:{name:"drupal-entity",key:this.attrs[e]}};t.for("dataDowncast").attributeToAttribute(i),t.for("upcast").attributeToAttribute(i)}))}async _loadPreview(t){const e={text:this._renderElement(t)},i=await fetch(Drupal.url("embed/preview/"+this.options.format+"?"+new URLSearchParams(e)),{headers:{"X-Drupal-EmbedPreview-CSRF-Token":this.options.previewCsrfToken}});if(i.ok){return{label:Drupal.t("Entity Embed widget"),preview:await i.text()}}return{label:this.labelError,preview:this.previewError}}_renderElement(t){const e=this.editor.model.change((e=>{const i=e.createDocumentFragment(),r=e.cloneElement(t,!1);return e.append(r,i),i}));return this.editor.data.stringify(e)}_getPreviewContainer(t){for(const e of t){if(e.hasAttribute("data-drupal-entity-preview"))return e;if(e.childCount){const t=this._getPreviewContainer(e.getChildren());if(t)return t}}return null}static get pluginName(){return"EntityEmbedEditing"}}var a=i("ckeditor5/src/ui.js");class d extends t.Plugin{static get requires(){return[e.WidgetToolbarRepository]}init(){const e=this.editor,i=e.plugins.get("EntityEmbedEditing"),r=e.config.get("entityEmbed"),{dialogSettings:n={}}=r;e.ui.componentFactory.add("entityEmbedEdit",(o=>{let d=new a.ButtonView(o);return d.set({label:e.t("Edit"),icon:t.icons.pencil,tooltip:!0}),this.listenTo(d,"execute",(t=>{let o=e.model.document.selection.getSelectedElement(),a=Drupal.url("entity-embed/dialog/"+r.format+"/"+o.getAttribute("drupalEntityEmbedButton")),d={};for(let[t,e]of o.getAttributes()){let r=i.attrs[t];r&&(d[r]=e)}this._openDialog(a,d,(({attributes:t})=>{e.execute("insertEntityEmbed",t),e.editing.view.focus()}),n)})),d}))}afterInit(){const{editor:t}=this;if(!t.plugins.has("WidgetToolbarRepository"))return;t.plugins.get("WidgetToolbarRepository").register("entityEmbed",{items:["entityEmbedEdit"],getRelatedElement(t){const i=t.getSelectedElement();return i&&(0,e.isWidget)(i)&&i.getCustomProperty("drupalEntity")?i:null}})}_openDialog(t,e,i,r){const n=r.dialogClass?r.dialogClass.split(" "):[];n.push("ui-dialog--narrow"),r.dialogClass=n.join(" "),r.autoResize=window.matchMedia("(min-width: 600px)").matches,r.width="auto";Drupal.ajax({dialog:r,dialogType:"modal",selector:".ckeditor5-dialog-loading-link",url:t,progress:{type:"fullscreen"},submit:{editor_object:e}}).execute(),Drupal.ckeditor5.saveCallback=i}static get pluginName(){return"EntityEmbedToolbar"}}class s extends t.Plugin{static get requires(){return["Widget"]}init(){const t=this.editor,e=t.commands.get("insertEntityEmbed"),i=t.config.get("entityEmbed");t.editing.view.document;if(!i)return;const{dialogSettings:r={}}=i,n=i.buttons;Object.keys(n).forEach((o=>{let d=Drupal.url("entity-embed/dialog/"+i.format+"/"+o);t.ui.componentFactory.add(o,(i=>{let s=n[o],l=new a.ButtonView(i),u=null;if(s.icon.endsWith("svg")){let t=new XMLHttpRequest;t.open("GET",s.icon,!1),t.send(null),u=t.response}return l.set({label:s.label,icon:u??'<?xml version="1.0" encoding="UTF-8" standalone="no"?>\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">  <image id="image0" width="16" height="16" x="0" y="0"\n    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAAAJiS0dE\nAP+Hj8y/AAAAB3RJTUUH5gkNAywZrK+VpAAAAElJREFUKM9jYKAeuMrwHwUuhwizoCj6xfALzv6J\nzYRKTIOZCNmMaoUpQzKcvZnhFX5HWmIz4SrDDTj7LbUcSVABbkfeJ9kEcgEApvsllE2X4VkAAAAl\ndEVYdGRhdGU6Y3JlYXRlADIwMjItMDktMTNUMDE6NDQ6MjUrMDI6MDCMUacyAAAAJXRFWHRkYXRl\nOm1vZGlmeQAyMDIyLTA5LTEzVDAxOjQ0OjI1KzAyOjAw/QwfjgAAAABJRU5ErkJggg==" />\n</svg>\n',tooltip:!0}),l.bind("isOn","isEnabled").to(e,"value","isEnabled"),this.listenTo(l,"execute",(()=>Drupal.ckeditor5.openDialog(d,(({attributes:e})=>{t.execute("insertEntityEmbed",e)}),r))),l}))}))}static get pluginName(){return"EntityEmbedUI"}}class l extends t.Plugin{static get requires(){return[o,s,d]}static get pluginName(){return"EntityEmbed"}}const u={EntityEmbed:l}})(),r=r.default})()));
\ No newline at end of file
diff -ruN a/js/ckeditor5_plugins/drupalentity/entity.svg b/js/ckeditor5_plugins/drupalentity/entity.svg
--- a/js/ckeditor5_plugins/drupalentity/entity.svg	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/entity.svg	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="16px" height="16px" viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">  <image id="image0" width="16" height="16" x="0" y="0"
+    href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAABGdBTUEAALGPC/xhBQAAAAJiS0dE
+AP+Hj8y/AAAAB3RJTUUH5gkNAywZrK+VpAAAAElJREFUKM9jYKAeuMrwHwUuhwizoCj6xfALzv6J
+zYRKTIOZCNmMaoUpQzKcvZnhFX5HWmIz4SrDDTj7LbUcSVABbkfeJ9kEcgEApvsllE2X4VkAAAAl
+dEVYdGRhdGU6Y3JlYXRlADIwMjItMDktMTNUMDE6NDQ6MjUrMDI6MDCMUacyAAAAJXRFWHRkYXRl
+Om1vZGlmeQAyMDIyLTA5LTEzVDAxOjQ0OjI1KzAyOjAw/QwfjgAAAABJRU5ErkJggg==" />
+</svg>
diff -ruN a/js/ckeditor5_plugins/drupalentity/src/command.js b/js/ckeditor5_plugins/drupalentity/src/command.js
--- a/js/ckeditor5_plugins/drupalentity/src/command.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/src/command.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,52 @@
+import {Command} from 'ckeditor5/src/core';
+
+export default class InsertEntityEmbedCommand extends Command {
+
+  execute(attributes) {
+    const { model } = this.editor;
+    const entityEmbedEditing = this.editor.plugins.get('EntityEmbedEditing');
+
+    // Create object that contains supported data-attributes in view data by
+    // flipping `EntityEmbedEditing.attrs` object (i.e. keys from object become
+    // values and values from object become keys).
+    const dataAttributeMapping = Object.entries(entityEmbedEditing.attrs).reduce(
+      (result, [key, value]) => {
+        result[value] = key;
+        return result;
+      },
+      {},
+    );
+
+    // \Drupal\entity_embed\Form\EntityEmbedDialog returns data in keyed by
+    // data-attributes used in view data. This converts data-attribute keys to
+    // keys used in model.
+    const modelAttributes = Object.keys(attributes).reduce(
+      (result, attribute) => {
+        if (dataAttributeMapping[attribute]) {
+          result[dataAttributeMapping[attribute]] = attributes[attribute];
+        }
+        return result;
+      },
+      {},
+    );
+
+    model.change((writer) => {
+      model.insertContent(createEntityEmbed(writer, modelAttributes));
+    });
+  }
+
+  refresh() {
+    const model = this.editor.model;
+    const selection = model.document.selection;
+    const allowedIn = model.schema.findAllowedParent(
+      selection.getFirstPosition(),
+      'drupalEntity',
+    );
+    this.isEnabled = allowedIn !== null;
+  };
+
+}
+
+function createEntityEmbed(writer, attributes) {
+  return writer.createElement('drupalEntity', attributes);
+}
diff -ruN a/js/ckeditor5_plugins/drupalentity/src/editing.js b/js/ckeditor5_plugins/drupalentity/src/editing.js
--- a/js/ckeditor5_plugins/drupalentity/src/editing.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/src/editing.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,288 @@
+import { Plugin } from 'ckeditor5/src/core';
+import { Widget, toWidget } from 'ckeditor5/src/widget';
+import InsertEntityEmbedCommand from './command';
+
+export default class EntityEmbedEditing extends Plugin {
+
+  /**
+   * @inheritdoc
+   */
+  static get requires() {
+    return [Widget];
+  }
+
+  /**
+   * @inheritdoc
+   */
+  init() {
+    this.attrs = {
+      alt: 'alt',
+      title: 'title',
+      dataCaption: 'data-caption',
+      dataAlign: 'data-align',
+      drupalEntityLangCode: 'data-langcode',
+      drupalEntityEntityType: 'data-entity-type',
+      drupalEntityEntityUuid: 'data-entity-uuid',
+      drupalEntityEmbedButton: 'data-embed-button',
+      drupalEntityEmbedDisplay: 'data-entity-embed-display',
+      drupalEntityEmbedDisplaySettings: 'data-entity-embed-display-settings',
+    };
+    const options = this.editor.config.get('entityEmbed');
+    if (!options) {
+      return;
+    }
+    this.options = options;
+    this.labelError = Drupal.t('Preview failed');
+    this.previewError =`
+      <p>${Drupal.t(
+        'An error occurred while trying to preview the embedded content. Please save your work and reload this page.',
+      )}<p>
+    `;
+
+    this._defineSchema();
+    this._defineConverters();
+    this.editor.commands.add(
+      'insertEntityEmbed',
+      new InsertEntityEmbedCommand(this.editor),
+    );
+  }
+
+  /**
+   * Registers drupalEntity as a block element in the DOM.
+   *
+   * @private
+   */
+  _defineSchema() {
+    const schema = this.editor.model.schema;
+
+    schema.register('drupalEntity', {
+      isObject: true,
+      isContent: true,
+      isBlock: true,
+      allowWhere: '$block',
+      allowAttributes: Object.keys(this.attrs),
+    });
+    this.editor.editing.view.domConverter.blockElements.push('drupal-entity');
+  }
+
+  /**
+   * Defines handling of drupalEntity elements.
+   *
+   * @private
+   */
+  _defineConverters() {
+    const {conversion} = this.editor;
+
+    conversion
+      .for('upcast')
+      .elementToElement({
+        model: 'drupalEntity',
+        view: {
+          name: 'drupal-entity',
+        },
+      });
+
+    conversion
+      .for('dataDowncast')
+      .elementToElement({
+        model: 'drupalEntity',
+        view: {
+          name: 'drupal-entity',
+        },
+      });
+
+    // Convert the <drupalEntity> model into an editable <drupal-entity> widget.
+    conversion
+      .for('editingDowncast')
+      .elementToElement({
+        model: 'drupalEntity',
+        view: (modelElement, { writer }) => {
+          const container = writer.createContainerElement('figure', {
+            class: 'drupal-entity',
+          });
+          writer.setCustomProperty('drupalEntity', true, container);
+
+          return toWidget(container, writer, {
+            label: Drupal.t('Entity Embed widget'),
+          })
+        },
+      })
+      .add((dispatcher) => {
+        const converter = (event, data, conversionApi) => {
+          const viewWriter = conversionApi.writer;
+          const modelElement = data.item;
+          const container = conversionApi.mapper.toViewElement(data.item);
+
+          let drupalEntity = this._getPreviewContainer(container.getChildren());
+          // Use existing container if it exists, create on if it does not.
+          if (drupalEntity) {
+            // Stop processing if a preview is already loading.
+            if (drupalEntity.getAttribute('data-drupal-entity-preview') !== 'ready') {
+              return;
+            }
+            // Preview was ready meaning that a new preview can be loaded.
+            // Change the attribute to loading to prepare for the loading of
+            // the updated preview. Preview is kept intact so that it remains
+            // interactable in the UI until the new preview has been rendered.
+            viewWriter.setAttribute(
+              'data-drupal-entity-preview',
+              'loading',
+              drupalEntity,
+            );
+          }
+          else {
+            drupalEntity = viewWriter.createRawElement('div', {
+              'data-drupal-entity-preview': 'loading',
+            });
+            viewWriter.insert(viewWriter.createPositionAt(container, 0), drupalEntity);
+          }
+
+          this._loadPreview(modelElement).then(({ label, preview }) => {
+            if (!drupalEntity) {
+              // Nothing to do if associated preview wrapped no longer exist.
+              return;
+            }
+            // CKEditor 5 doesn't support async view conversion. Therefore, once
+            // the promise is fulfilled, the editing view needs to be modified
+            // manually.
+            this.editor.editing.view.change((writer) => {
+              const drupalEntityPreview = writer.createRawElement(
+                'div',
+                {'data-drupal-entity-preview': 'ready', 'aria-label': label},
+                (domElement) => {
+                  domElement.innerHTML = preview;
+                },
+              );
+              // Insert the new preview before the previous preview element to
+              // ensure that the location remains same even if it is wrapped
+              // with another element.
+              writer.insert(writer.createPositionBefore(drupalEntity), drupalEntityPreview);
+              writer.remove(drupalEntity);
+            });
+          });
+        }
+
+        dispatcher.on('attribute:drupalEntityEntityUuid:drupalEntity', converter);
+
+        return dispatcher;
+      });
+
+    // Set attributeToAttribute conversion for all supported attributes.
+    Object.keys(this.attrs).forEach((modelKey) => {
+      const attributeMapping = {
+        model: {
+          key: modelKey,
+          name: 'drupalEntity',
+        },
+        view: {
+          name: 'drupal-entity',
+          key: this.attrs[modelKey],
+        },
+      };
+      // Attributes should be rendered only in dataDowncast to avoid having
+      // unfiltered data-attributes on the Drupal Entity widget.
+      conversion.for('dataDowncast').attributeToAttribute(attributeMapping);
+      conversion.for('upcast').attributeToAttribute(attributeMapping);
+    });
+  }
+
+  /**
+   * Loads the preview.
+   *
+   * @param modelElement
+   *   The model element which preview should be loaded.
+   * @returns {Promise<{preview: string, label: *}|{preview: *, label: string}>}
+   *   A promise that returns an object.
+   *
+   * @private
+   *
+   * @see DrupalMediaEditing::_fetchPreview().
+   */
+  async _loadPreview(modelElement) {
+    const query = {
+      text: this._renderElement(modelElement),
+    };
+
+    const response = await fetch(
+      Drupal.url('embed/preview/' + this.options.format + '?' + new URLSearchParams(query)),
+      {
+        headers: {
+          'X-Drupal-EmbedPreview-CSRF-Token':
+          this.options.previewCsrfToken,
+        },
+      },
+    );
+
+    if (response.ok) {
+      const label = Drupal.t('Entity Embed widget');
+      const preview = await response.text();
+      return { label, preview };
+    }
+
+    return { label: this.labelError, preview: this.previewError };
+  }
+
+  /**
+   * Renders the model element.
+   *
+   * @param modelElement
+   *   The drupalMedia model element to be converted.
+   * @returns {*}
+   *   The model element converted into HTML.
+   *
+   * @private
+   */
+  _renderElement(modelElement) {
+    // Create model document fragment which contains the model element so that
+    // it can be stringified using the dataDowncast.
+    const modelDocumentFragment = this.editor.model.change((writer) => {
+      const modelDocumentFragment = writer.createDocumentFragment();
+      // Create shallow clone of the model element to ensure that the original
+      // model element remains untouched and that the caption is not rendered
+      // into the preview.
+      const clonedModelElement = writer.cloneElement(modelElement, false);
+      writer.append(clonedModelElement, modelDocumentFragment);
+
+      return modelDocumentFragment;
+    });
+
+    return this.editor.data.stringify(modelDocumentFragment);
+  }
+
+  /**
+   * Gets the preview container element.
+   *
+   * @param children
+   *   The child elements.
+   * @returns {null|*}
+   *    The preview child element if available.
+   *
+   * @private
+   */
+  _getPreviewContainer(children) {
+    for (const child of children) {
+      if (child.hasAttribute('data-drupal-entity-preview')) {
+        return child;
+      }
+
+      if (child.childCount) {
+        const recursive = this._getPreviewContainer(child.getChildren());
+        // Return only if preview container was found within this element's
+        // children.
+        if (recursive) {
+          return recursive;
+        }
+      }
+    }
+
+    return null;
+  }
+
+  /**
+   * @inheritdoc
+   */
+  static get pluginName() {
+    return 'EntityEmbedEditing';
+  }
+
+}
diff -ruN a/js/ckeditor5_plugins/drupalentity/src/entityembed.js b/js/ckeditor5_plugins/drupalentity/src/entityembed.js
--- a/js/ckeditor5_plugins/drupalentity/src/entityembed.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/src/entityembed.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,19 @@
+import EntityEmbedEditing from './editing';
+import EntityEmbedToolbar from './toolbar';
+import EntityEmbedUI from './ui';
+import { Plugin } from 'ckeditor5/src/core';
+
+export default class EntityEmbed extends Plugin {
+
+  static get requires() {
+    return [EntityEmbedEditing, EntityEmbedUI, EntityEmbedToolbar];
+  }
+
+  /**
+   * @inheritdoc
+   */
+  static get pluginName() {
+    return 'EntityEmbed';
+  }
+
+}
diff -ruN a/js/ckeditor5_plugins/drupalentity/src/index.js b/js/ckeditor5_plugins/drupalentity/src/index.js
--- a/js/ckeditor5_plugins/drupalentity/src/index.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/src/index.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,9 @@
+/**
+ * @module entity-embed
+ */
+
+import EntityEmbed from './entityembed';
+
+export default {
+  EntityEmbed,
+};
diff -ruN a/js/ckeditor5_plugins/drupalentity/src/toolbar.js b/js/ckeditor5_plugins/drupalentity/src/toolbar.js
--- a/js/ckeditor5_plugins/drupalentity/src/toolbar.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/src/toolbar.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,135 @@
+import { Plugin, icons } from 'ckeditor5/src/core';
+import { isWidget, WidgetToolbarRepository } from 'ckeditor5/src/widget';
+import { ButtonView } from "ckeditor5/src/ui";
+
+export default class EntityEmbedToolbar extends Plugin {
+
+  /**
+   * @inheritdoc
+   */
+  static get requires() {
+    return [WidgetToolbarRepository];
+  }
+
+  /**
+   * @inheritdoc
+   */
+  init() {
+    const editor = this.editor;
+    const entityEmbedEditing = editor.plugins.get('EntityEmbedEditing');
+    const options = editor.config.get('entityEmbed');
+    const { dialogSettings = {} } = options;
+
+    editor.ui.componentFactory.add('entityEmbedEdit', (locale) => {
+      let buttonView = new ButtonView(locale);
+
+      buttonView.set({
+        label: editor.t('Edit'),
+        icon: icons.pencil,
+        tooltip: true,
+      })
+
+      this.listenTo(buttonView, 'execute', (eventInfo) => {
+        let element = editor.model.document.selection.getSelectedElement();
+        let libraryURL = Drupal.url('entity-embed/dialog/' + options.format + '/' + element.getAttribute('drupalEntityEmbedButton'));
+
+        let existingValues = {};
+
+        for (let [key, value] of element.getAttributes()) {
+          let attribute = entityEmbedEditing.attrs[key]
+          if (attribute) {
+            existingValues[attribute] = value
+          }
+        }
+
+        // Open a dialog to select entity to embed.
+        this._openDialog(
+          libraryURL,
+          existingValues,
+          ({ attributes }) => {
+            editor.execute('insertEntityEmbed', attributes);
+            editor.editing.view.focus();
+          },
+          dialogSettings,
+        )
+      });
+
+      return buttonView;
+    })
+  }
+
+  /**
+   * @inheritdoc
+   */
+  afterInit() {
+    const { editor } = this
+    if (!editor.plugins.has('WidgetToolbarRepository')) {
+      return;
+    }
+    const widgetToolbarRepository = editor.plugins.get('WidgetToolbarRepository')
+
+    widgetToolbarRepository.register('entityEmbed', {
+      items: ['entityEmbedEdit'],
+      getRelatedElement(selection) {
+        const viewElement = selection.getSelectedElement()
+        if (!viewElement) {
+          return null
+        }
+        if (!isWidget(viewElement)) {
+          return null
+        }
+        if (!viewElement.getCustomProperty('drupalEntity')) {
+          return null
+        }
+
+        return viewElement
+      },
+    })
+  }
+
+  /**
+   * @param {string} url
+   *   The URL that contains the contents of the dialog.
+   * @param {object} existingValues
+   *   Existing values that will be sent via POST to the url for the dialog
+   *   contents.
+   * @param {function} saveCallback
+   *   A function to be called upon saving the dialog.
+   * @param {object} dialogSettings
+   *   An object containing settings to be passed to the jQuery UI.
+   */
+  _openDialog(url, existingValues, saveCallback, dialogSettings) {
+    // Add a consistent dialog class.
+    const classes = dialogSettings.dialogClass
+      ? dialogSettings.dialogClass.split(' ')
+      : [];
+    classes.push('ui-dialog--narrow');
+    dialogSettings.dialogClass = classes.join(' ');
+    dialogSettings.autoResize =
+      window.matchMedia('(min-width: 600px)').matches;
+    dialogSettings.width = 'auto';
+
+    const ckeditorAjaxDialog = Drupal.ajax({
+      dialog: dialogSettings,
+      dialogType: 'modal',
+      selector: '.ckeditor5-dialog-loading-link',
+      url,
+      progress: { type: 'fullscreen' },
+      submit: {
+        editor_object: existingValues,
+      },
+    });
+    ckeditorAjaxDialog.execute();
+
+    // Store the save callback to be executed when this dialog is closed.
+    Drupal.ckeditor5.saveCallback = saveCallback;
+  }
+
+  /**
+   * @inheritdoc
+   */
+  static get pluginName() {
+    return 'EntityEmbedToolbar';
+  }
+
+}
diff -ruN a/js/ckeditor5_plugins/drupalentity/src/ui.js b/js/ckeditor5_plugins/drupalentity/src/ui.js
--- a/js/ckeditor5_plugins/drupalentity/src/ui.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/ckeditor5_plugins/drupalentity/src/ui.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,79 @@
+/**
+ * @file Registers the entity embed button(s) to the CKEditor instance(s) and binds functionality to it/them.
+ */
+
+import { Plugin } from 'ckeditor5/src/core';
+import { ButtonView } from 'ckeditor5/src/ui';
+import defaultIcon from '../entity.svg';
+
+export default class EntityEmbedUI extends Plugin {
+
+  /**
+   * @inheritdoc
+   */
+  static get requires() {
+    return ['Widget'];
+  }
+
+  /**
+   * @inheritdoc
+   */
+  init() {
+    const editor = this.editor;
+    const command = editor.commands.get('insertEntityEmbed');
+    const options = editor.config.get('entityEmbed');
+    const viewDocument = editor.editing.view.document;
+    if (!options) {
+      return;
+    }
+    const { dialogSettings = {} } = options;
+    const embed_buttons = options.buttons;
+
+    // Register each embed button to the toolbar based on configuration.
+    Object.keys(embed_buttons).forEach(id => {
+      let libraryURL = Drupal.url('entity-embed/dialog/' + options.format + '/' + id);
+      // Add each button to the toolbar.
+      editor.ui.componentFactory.add(id, (locale) => {
+        let button = embed_buttons[id];
+        let buttonView = new ButtonView(locale);
+        // Set the icon to the SVG from config, or set it to the default icon.
+        // If the uploaded icon is an SVG, load it or use the default icon otherwise.
+        let icon = null;
+        if (button.icon.endsWith('svg')) {
+          let XMLrequest = new XMLHttpRequest();
+          XMLrequest.open("GET", button.icon, false);
+          XMLrequest.send(null);
+          icon = XMLrequest.response;
+        }
+
+        buttonView.set({
+          label: button.label,
+          icon: icon ?? defaultIcon,
+          tooltip: true,
+        });
+        buttonView.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled');
+
+        this.listenTo(buttonView, 'execute', () =>
+          // Open a dialog to select entity to embed.
+          Drupal.ckeditor5.openDialog(
+            libraryURL,
+            ({ attributes }) => {
+              editor.execute('insertEntityEmbed', attributes);
+            },
+            dialogSettings,
+          ),
+        );
+
+        return buttonView;
+      })
+    });
+  }
+
+  /**
+   * @inheritdoc
+   */
+  static get pluginName() {
+    return 'EntityEmbedUI';
+  }
+
+}
diff -ruN a/js/entity_embed.dialog.js b/js/entity_embed.dialog.js
--- a/js/entity_embed.dialog.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/entity_embed.dialog.js	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,55 @@
+/**
+ * @file
+ * Provides JavaScript additions to entity embed dialog.
+ *
+ * This file provides popup windows for previewing embedded entities from the
+ * embed dialog.
+ */
+
+(function ($, Drupal, once) {
+
+  "use strict";
+
+  /**
+   * Attach behaviors to links for entities.
+   */
+  Drupal.behaviors.entityEmbedPreviewEntities = {
+    attach: function (context) {
+      $(context).find('form.entity-embed-dialog .form-item-entity a').on('click', Drupal.entityEmbedDialog.openInNewWindow);
+    },
+    detach: function (context) {
+      $(context).find('form.entity-embed-dialog .form-item-entity a').off('click', Drupal.entityEmbedDialog.openInNewWindow);
+    }
+  };
+
+  /**
+   * Behaviors for the entityEmbedDialog iframe.
+   */
+  Drupal.behaviors.entityEmbedDialog = {
+    attach: function (context, settings) {
+      $(once('js-entity-embed-dialog', 'body')).on('entityBrowserIFrameAppend', function () {
+        $('.entity-select-dialog').trigger('resize');
+        // Hide the next button, the click is triggered by Drupal.entityEmbedDialog.selectionCompleted.
+        $('#drupal-modal').parent().find('.js-button-next').addClass('visually-hidden');
+      });
+    }
+  };
+
+  /**
+   * Entity Embed dialog utility functions.
+   */
+  Drupal.entityEmbedDialog = Drupal.entityEmbedDialog || {
+    /**
+     * Open links to entities within forms in a new window.
+     */
+    openInNewWindow: function (event) {
+      event.preventDefault();
+      $(this).attr('target', '_blank');
+      window.open(this.href, 'entityPreview', 'toolbar=0,scrollbars=1,location=1,statusbar=1,menubar=0,resizable=1');
+    },
+    selectionCompleted: function(event, uuid, entities) {
+      $('.entity-select-dialog .js-button-next').click();
+    }
+  };
+
+})(jQuery, Drupal, once);
diff -ruN a/js/entity_embed.set_dynamic_icons.js b/js/entity_embed.set_dynamic_icons.js
--- a/js/entity_embed.set_dynamic_icons.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/entity_embed.set_dynamic_icons.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,18 @@
+/* This script is responsible for setting the correct image(s) on the admin
+ * toolbar, as we cannot build the JS for it because we do not know how
+ * many entity embed buttons are there in the system. The number of buttons
+ * created are based on the number of embed buttons.
+ */
+(function ($, Drupal, drupalSettings, once) {
+  Drupal.behaviors.entityEmbedSetDynamicIcons = {
+    attach: function (context) {
+      // Get the available Embed Buttons from Drupal.
+      Object.values(drupalSettings.embedButtons || {}).forEach(function (button) {
+        // Iterate through the embed buttons and set the corresponding background image.
+        let selector = '.ckeditor5-toolbar-button-' + button.id;
+        let iconUrl = button.icon.endsWith('svg') ? button.icon : '/' + drupalSettings.modulePath + '/js/ckeditor5_plugins/drupalentity/entity.svg';
+        $(once('entityEmbedSetDynamicIcons', selector, context)).css('background-image', 'url(' + iconUrl + ')');
+      });
+    },
+  }
+})(jQuery, Drupal, drupalSettings, once);
Binary files a/js/plugins/drupalentity/entity.png and b/js/plugins/drupalentity/entity.png differ
diff -ruN a/js/plugins/drupalentity/plugin.js b/js/plugins/drupalentity/plugin.js
--- a/js/plugins/drupalentity/plugin.js	1970-01-01 01:00:00.000000000 +0100
+++ b/js/plugins/drupalentity/plugin.js	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,439 @@
+/**
+ * @file
+ * Drupal Entity embed plugin.
+ */
+
+(function (jQuery, Drupal, CKEDITOR) {
+
+  "use strict";
+
+  function getFocusedWidget(editor) {
+    var widget = editor.widgets.focused;
+
+    if (widget && widget.name === 'drupalentity') {
+      return widget;
+    }
+
+    return null;
+  }
+
+  function linkCommandIntegrator(editor) {
+    if (!editor.plugins.drupallink) {
+      return;
+    }
+
+    editor.getCommand('drupalunlink').on('exec', function (evt) {
+      var widget = getFocusedWidget(editor);
+
+      if (!widget) {
+        return;
+      }
+
+      widget.setData('link', null);
+
+      this.refresh(editor, editor.elementPath());
+
+      evt.cancel();
+    });
+
+    editor.getCommand('drupalunlink').on('refresh', function (evt) {
+      var widget = getFocusedWidget(editor);
+
+      if (!widget) {
+        return;
+      }
+
+      this.setState(widget.data.link ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
+
+      evt.cancel();
+    });
+  }
+
+  CKEDITOR.plugins.add('drupalentity', {
+    requires: 'widget',
+
+    beforeInit: function (editor) {
+      // Configure CKEditor DTD for custom drupal-entity element.
+      // @see https://www.drupal.org/node/2448449#comment-9717735
+      var dtd = CKEDITOR.dtd, tagName;
+      dtd['drupal-entity'] = {'#': 1};
+      // Register drupal-entity element as an allowed child in each tag that can
+      // contain a div element.
+      for (tagName in dtd) {
+        if (dtd[tagName].div) {
+          dtd[tagName]['drupal-entity'] = 1;
+        }
+      }
+      dtd['a']['drupal-entity'] = 1;
+
+      // The drupallink plugin has a hardcoded integration with
+      // drupalimage.  If the drupallink plugin has the
+      // registerLinkableWidget() method (which was added in Drupal 8.8), we
+      // don't need this workaround.
+      if (editor.plugins.drupallink) {
+        if (CKEDITOR.plugins.drupallink.hasOwnProperty('registerLinkableWidget')) {
+          CKEDITOR.plugins.drupallink.registerLinkableWidget('drupalentity');
+        } else {
+          // drupallink has a hardcoded integration with drupalimage. Workaround
+          // that, to reuse the same integration.
+          var originalGetFocusedWidget = null;
+          if (CKEDITOR.plugins.drupalimage) {
+            originalGetFocusedWidget = CKEDITOR.plugins.drupalimage.getFocusedWidget;
+          } else {
+            CKEDITOR.plugins.drupalimage = {};
+          }
+          CKEDITOR.plugins.drupalimage.getFocusedWidget = function () {
+            var ourFocusedWidget = getFocusedWidget(editor);
+            if (ourFocusedWidget) {
+              return ourFocusedWidget;
+            }
+            // If drupalimage is loaded, call that next, to not break its link command integration.
+            if (originalGetFocusedWidget) {
+              return originalGetFocusedWidget(editor);
+            }
+            return null;
+          };
+        }
+      }
+
+      // Generic command for adding/editing entities of all types.
+      editor.addCommand('editdrupalentity', {
+        allowedContent: 'drupal-entity[data-embed-button,data-entity-type,data-entity-uuid,data-entity-embed-display,data-entity-embed-display-settings,data-align,data-caption]',
+        requiredContent: 'drupal-entity[data-embed-button,data-entity-type,data-entity-uuid,data-entity-embed-display,data-entity-embed-display-settings,data-align,data-caption]',
+        modes: { wysiwyg : 1 },
+        canUndo: true,
+        exec: function (editor, data) {
+          data = data || {};
+
+          var existingElement = getSelectedEmbeddedEntity(editor);
+          var existingWidget = (existingElement) ? editor.widgets.getByElement(existingElement, true) : null;
+
+          var existingValues = {};
+
+          // Host entity's langcode added in entity_embed_field_widget_form_alter().
+          var hostEntityLangcode = document.getElementById(editor.name).getAttribute('data-entity_embed-host-entity-langcode');
+          if (hostEntityLangcode) {
+            existingValues['data-langcode'] = hostEntityLangcode;
+          }
+
+          if (existingWidget) {
+            existingValues = existingWidget.data.attributes;
+          }
+
+          var embed_button_id = data.id ? data.id : existingValues['data-embed-button'];
+
+          var dialogSettings = {
+            dialogClass: 'entity-select-dialog',
+            resizable: false
+          };
+
+          var saveCallback = function (values) {
+            editor.fire('saveSnapshot');
+            if (!existingElement) {
+              var entityElement = editor.document.createElement('drupal-entity');
+              var attributes = values.attributes;
+              for (var key in attributes) {
+                entityElement.setAttribute(key, attributes[key]);
+              }
+              editor.insertHtml(entityElement.getOuterHtml());
+            }
+            else {
+              var hasCaption = false;
+              if (values.attributes['data-caption']) {
+                values.attributes['data-caption'] = CKEDITOR.tools.htmlDecodeAttr(values.attributes['data-caption']);
+                hasCaption = true;
+              }
+              existingWidget.setData({ attributes: values.attributes, hasCaption: hasCaption });
+            }
+            editor.fire('saveSnapshot');
+          };
+
+          // Open the entity embed dialog for corresponding EmbedButton.
+          Drupal.ckeditor.openDialog(editor, Drupal.url('entity-embed/dialog/' + editor.config.drupal.format + '/' + embed_button_id), existingValues, saveCallback, dialogSettings);
+        }
+      });
+
+      // Register the entity embed widget.
+      editor.widgets.add('drupalentity', {
+        // Minimum HTML which is required by this widget to work.
+        allowedContent: 'drupal-entity[data-entity-type,data-entity-uuid,data-entity-embed-display,data-entity-embed-display-settings,data-align,data-caption]',
+        requiredContent: 'drupal-entity[data-entity-type,data-entity-uuid,data-entity-embed-display,data-entity-embed-display-settings,data-align,data-caption]',
+
+        pathName: Drupal.t('Embedded entity'),
+
+        editables: {
+          caption: {
+            selector: 'figcaption',
+            allowedContent: 'a[!href]; em strong cite code br',
+            pathName: Drupal.t('Caption'),
+          }
+        },
+
+        upcast: function (element, data) {
+          var attributes = element.attributes;
+          if (element.name !== 'drupal-entity' || attributes['data-entity-type'] === undefined || (attributes['data-entity-id'] === undefined && attributes['data-entity-uuid'] === undefined) || (attributes['data-view-mode'] === undefined && attributes['data-entity-embed-display'] === undefined)) {
+            return;
+          }
+          data.attributes = CKEDITOR.tools.copy(attributes);
+          data.hasCaption = data.attributes.hasOwnProperty('data-caption');
+          data.link = null;
+          if (element.parent.name === 'a') {
+            data.link = CKEDITOR.tools.copy(element.parent.attributes);
+            // Omit CKEditor-internal attributes.
+            Object.keys(element.parent.attributes).forEach(function (attrName) {
+              if (attrName.indexOf('data-cke-') !== -1) {
+                delete data.link[attrName];
+              }
+            });
+          }
+          return element;
+        },
+
+        init: function () {
+          /** @type {CKEDITOR.dom.element} */
+          var element = this.element;
+
+          // See https://www.drupal.org/node/2544018.
+          if (element.hasAttribute('data-embed-button')) {
+            var buttonId = element.getAttribute('data-embed-button');
+            if (editor.config.DrupalEntity_buttons[buttonId]) {
+              var button = editor.config.DrupalEntity_buttons[buttonId];
+              this.wrapper.data('cke-display-name', Drupal.t('Embedded @buttonLabel', {'@buttonLabel': button.label}));
+            }
+          }
+        },
+
+        destroy: function() {
+          this._tearDownDynamicEditables();
+        },
+
+        data: function (event) {
+          if (this._previewNeedsServersideUpdate()) {
+            editor.fire('lockSnapshot');
+            this._tearDownDynamicEditables();
+
+            this._loadPreview(function (widget) {
+              widget._setUpDynamicEditables();
+              editor.fire('unlockSnapshot');
+              editor.fire('saveSnapshot');
+            });
+          }
+          // @todo Remove in https://www.drupal.org/project/entity_embed/issues/3060397
+          else if (this._previewNeedsClientsideUpdate()) {
+            this._performClientsideUpdate();
+            editor.fire('saveSnapshot');
+          }
+
+          // Allow entity_embed.editor.css to respond to changes (for example in alignment).
+          this.element.setAttributes(this.data.attributes);
+
+          // Track the previous state, to allow for smarter decisions.
+          this.oldData = CKEDITOR.tools.clone(this.data);
+        },
+
+        downcast: function () {
+          var downcastElement = new CKEDITOR.htmlParser.element('drupal-entity', this.data.attributes);
+          if (this.data.link) {
+            var link = new CKEDITOR.htmlParser.element('a', this.data.link);
+            link.add(downcastElement);
+            downcastElement = link;
+          }
+          return downcastElement;
+        },
+
+        _setUpDynamicEditables: function () {
+          // Now that the caption is available in the DOM, make it editable.
+          if (this.initEditable('caption', this.definition.editables.caption)) {
+            var captionEditable = this.editables.caption;
+            // @see core/modules/filter/css/filter.caption.css
+            // @see ckeditor_ckeditor_css_alter()
+            captionEditable.setAttribute('data-placeholder', Drupal.t('Enter caption here'));
+            // And ensure that any changes made to it are persisted.
+            var config = {characterData: true, attributes: true, childList: true, subtree: true};
+            var widget = this;
+            this.captionEditableMutationObserver = new MutationObserver(function () {
+              var entityAttributes = CKEDITOR.tools.clone(widget.data.attributes);
+              entityAttributes['data-caption'] = captionEditable.getData();
+              widget.setData('attributes', entityAttributes);
+            });
+            this.captionEditableMutationObserver.observe(captionEditable.$, config);
+          }
+        },
+
+        _tearDownDynamicEditables: function () {
+          if (this.captionEditableMutationObserver) {
+            this.captionEditableMutationObserver.disconnect();
+          }
+        },
+
+        _previewNeedsServersideUpdate: function () {
+          // When the widget is first loading, it of course needs to still get a preview!
+          if (!this.ready) {
+            return true;
+          }
+
+          return this._hashData(this.oldData) !== this._hashData(this.data);
+        },
+
+        // @todo Remove in https://www.drupal.org/project/entity_embed/issues/3060397
+        _previewNeedsClientsideUpdate: function () {
+          // The preview's caption must be updated when the caption was edited in EntityEmbedDialog.
+          // @see https://www.drupal.org/project/entity_embed/issues/3060397
+          if (this.data.hasCaption && this.editables.caption.getData() !== this.data.attributes['data-caption']) {
+            return true;
+          }
+
+          return false;
+        },
+
+        // @todo Remove in https://www.drupal.org/project/entity_embed/issues/3060397
+        _performClientsideUpdate: function () {
+          if (this.data.hasCaption) {
+            this.captionEditableMutationObserver.disconnect();
+            this.editables.caption.$.innerHTML = this.data.attributes['data-caption'];
+            var config = {characterData: true, attributes: false, childList: true, subtree: true};
+            this.captionEditableMutationObserver.observe(this.editables.caption.$, config);
+          }
+        },
+
+        /**
+         * Computes a hash of the data that can only be previewed by the server.
+         */
+        _hashData: function (data) {
+          var dataToHash = CKEDITOR.tools.clone(data);
+          // The caption does not need rendering.
+          if (dataToHash.attributes.hasOwnProperty('data-caption')) {
+            delete dataToHash.attributes['data-caption'];
+          }
+          // Changed link destinations do not affect the visual preview.
+          if (dataToHash.link && dataToHash.link.hasOwnProperty('href')) {
+            delete dataToHash.link.href;
+          }
+          return JSON.stringify(dataToHash);
+        },
+
+        /**
+         * Loads an entity embed preview, calls a callback after insertion.
+         *
+         * @param {function} callback
+         *   A callback function that will be called after the preview has loaded, and receives the widget instance.
+         */
+        _loadPreview: function (callback) {
+          var widget = this;
+          jQuery.get({
+            url: Drupal.url('embed/preview/' + editor.config.drupal.format + '?text=' + encodeURIComponent(this.downcast().getOuterHtml())),
+            dataType: 'html',
+            headers: {
+              'X-Drupal-EmbedPreview-CSRF-Token': editor.config.DrupalEntity_previewCsrfToken
+            },
+          }).done(function(previewHtml) {
+            widget.element.setHtml(previewHtml);
+            callback(widget);
+          });
+        }
+      });
+
+      editor.widgets.on('instanceCreated', function (event) {
+        var widget = event.data;
+
+        if (widget.name !== 'drupalentity') {
+          return;
+        }
+
+        widget.on('edit', function (event) {
+          event.cancel();
+          // @see https://www.drupal.org/node/2544018
+          if (isEditableEntityWidget(editor, event.sender.wrapper)) {
+            editor.execCommand('editdrupalentity');
+          }
+        });
+      });
+
+      // Register the toolbar buttons.
+      if (editor.ui.addButton) {
+        for (var key in editor.config.DrupalEntity_buttons) {
+          var button = editor.config.DrupalEntity_buttons[key];
+          editor.ui.addButton(button.id, {
+            label: button.label,
+            data: button,
+            allowedContent: 'drupal-entity[!data-entity-type,!data-entity-uuid,!data-entity-embed-display,!data-entity-embed-display-settings,!data-align,!data-caption,!data-embed-button,!data-langcode,!alt,!title]',
+            click: function(editor) {
+              editor.execCommand('editdrupalentity', this.data);
+            },
+            icon: button.image,
+            modes: {wysiwyg: 1, source: 0}
+          });
+        }
+      }
+
+      // Register context menu items for editing widget.
+      if (editor.contextMenu) {
+        editor.addMenuGroup('drupalentity');
+
+        for (var key in editor.config.DrupalEntity_buttons) {
+          var button = editor.config.DrupalEntity_buttons[key];
+
+          var label = Drupal.t('Edit @buttonLabel', { '@buttonLabel': button.label });
+
+          editor.addMenuItem('drupalentity_' + button.id, {
+            label: label,
+            icon: button.image,
+            command: 'editdrupalentity',
+            group: 'drupalentity'
+          });
+        }
+
+        editor.contextMenu.addListener(function(element) {
+          if (isEditableEntityWidget(editor, element)) {
+            var button_id = element.getFirst().getAttribute('data-embed-button');
+            var returnData = {};
+            returnData['drupalentity_' + button_id] = CKEDITOR.TRISTATE_OFF;
+            return returnData;
+          }
+        });
+      }
+    },
+
+    afterInit: function (editor) {
+      linkCommandIntegrator(editor);
+    }
+  });
+
+  /**
+   * Get the surrounding drupalentity widget element.
+   *
+   * @param {CKEDITOR.editor} editor
+   */
+  function getSelectedEmbeddedEntity(editor) {
+    var selection = editor.getSelection();
+    var selectedElement = selection.getSelectedElement();
+    if (isEditableEntityWidget(editor, selectedElement)) {
+      return selectedElement;
+    }
+
+    return null;
+  }
+
+  /**
+   * Checks if the given element is an editable drupalentity widget.
+   *
+   * @param {CKEDITOR.editor} editor
+   * @param {CKEDITOR.htmlParser.element} element
+   */
+  function isEditableEntityWidget (editor, element) {
+    var widget = editor.widgets.getByElement(element, true);
+    if (!widget || widget.name !== 'drupalentity') {
+      return false;
+    }
+
+    var button = element.$.firstChild.getAttribute('data-embed-button');
+    if (!button) {
+      // If there was no data-embed-button attribute, not editable.
+      return false;
+    }
+
+    // The button itself must be valid.
+    return editor.config.DrupalEntity_buttons.hasOwnProperty(button);
+  }
+
+})(jQuery, Drupal, CKEDITOR);
diff -ruN a/package.json b/package.json
--- a/package.json	1970-01-01 01:00:00.000000000 +0100
+++ b/package.json	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,19 @@
+{
+  "name": "drupal-entity-embed",
+  "version": "1.0.0",
+  "description": "Drupal Entity Embed CKEditor 5 integration",
+  "author": "",
+  "license": "GPL-2.0-or-later",
+  "scripts": {
+    "watch": "webpack --mode development --watch",
+    "build": "webpack"
+  },
+  "devDependencies": {
+    "@ckeditor/ckeditor5-dev-utils": "^30.0.0",
+    "ckeditor5": "~34.1.0",
+    "raw-loader": "^4.0.2",
+    "terser-webpack-plugin": "^5.2.0",
+    "webpack": "^5.51.1",
+    "webpack-cli": "^4.4.0"
+  }
+}
diff -ruN a/src/Annotation/EntityEmbedDisplay.php b/src/Annotation/EntityEmbedDisplay.php
--- a/src/Annotation/EntityEmbedDisplay.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Annotation/EntityEmbedDisplay.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,68 @@
+<?php
+
+namespace Drupal\entity_embed\Annotation;
+
+use Drupal\Component\Annotation\Plugin;
+
+/**
+ * Defines an Entity Embed Display plugin annotation object.
+ *
+ * Plugin Namespace: Plugin/entity_embed/EntityEmbedDisplay.
+ *
+ * For a working example, see \Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay\FileFieldFormatter
+ *
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayBase
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+ * @see plugin_api
+ *
+ * @ingroup entity_embed_api
+ *
+ * @Annotation
+ */
+class EntityEmbedDisplay extends Plugin {
+
+  /**
+   * The plugin ID.
+   *
+   * @var string
+   */
+  public $id;
+
+  /**
+   * The human-readable name of the Entity Embed Display plugin.
+   *
+   * @var \Drupal\Core\Annotation\Translation
+   *
+   * @ingroup plugin_translatable
+   */
+  public $label = '';
+
+  /**
+   * The entity types the Entity Embed Display plugin can apply to.
+   *
+   * To make the Entity Embed Display plugin valid for all entity types, set
+   * this value to FALSE.
+   *
+   * @var bool|array
+   */
+  public $entity_types = FALSE;
+
+  /**
+   * Shows plugin in the UI if this is FALSE.
+   *
+   * @var bool
+   */
+  public $no_ui = FALSE;
+
+  /**
+   * Alt and title access.
+   *
+   * Whether the plugin supports per-embed alt and title overrides for media
+   * entities with an image source.
+   *
+   * @var bool
+   */
+  public $supports_image_alt_and_title = FALSE;
+
+}
diff -ruN a/src/Entity/EntityEmbedFakeEntity.php b/src/Entity/EntityEmbedFakeEntity.php
--- a/src/Entity/EntityEmbedFakeEntity.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Entity/EntityEmbedFakeEntity.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,20 @@
+<?php
+
+namespace Drupal\entity_embed\Entity;
+
+use Drupal\Core\Entity\ContentEntityBase;
+
+/**
+ * Fake entity type.
+ *
+ * @ContentEntityType(
+ *   id = "entity_embed_fake_entity",
+ *   label = @Translation("Fake entity type"),
+ *   handlers = {
+ *     "storage" = "Drupal\Core\Entity\ContentEntityNullStorage",
+ *   },
+ *   internal = true,
+ * )
+ */
+class EntityEmbedFakeEntity extends ContentEntityBase {
+}
diff -ruN a/src/EntityEmbedBuilder.php b/src/EntityEmbedBuilder.php
--- a/src/EntityEmbedBuilder.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/EntityEmbedBuilder.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,162 @@
+<?php
+
+namespace Drupal\entity_embed;
+
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager;
+
+/**
+ * Builds embedded entities.
+ *
+ * @internal
+ */
+class EntityEmbedBuilder implements EntityEmbedBuilderInterface {
+
+  /**
+   * The module handler service.
+   *
+   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   */
+  protected $moduleHandler;
+
+  /**
+   * The entity embed display plugin manager service.
+   *
+   * @var \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+   */
+  protected $displayPluginManager;
+
+  /**
+   * Constructs a EntityEmbedBuilder object.
+   *
+   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   *   The module handler service.
+   * @param \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager $display_manager
+   *   The entity embed display plugin manager.
+   */
+  public function __construct(ModuleHandlerInterface $module_handler, EntityEmbedDisplayManager $display_manager) {
+    $this->moduleHandler = $module_handler;
+    $this->displayPluginManager = $display_manager;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildEntityEmbed(EntityInterface $entity, array $context = []) {
+    // Support the deprecated view-mode data attribute.
+    if (isset($context['data-view-mode']) && !isset($context['data-entity-embed-display']) && !isset($context['data-entity-embed-display-settings'])) {
+      $context['data-entity-embed-display'] = 'entity_reference:entity_reference_entity_view';
+      $context['data-entity-embed-display-settings'] = ['view_mode' => &$context['data-view-mode']];
+    }
+
+    // Merge in default attributes.
+    $context += [
+      'data-entity-type' => $entity->getEntityTypeId(),
+      'data-entity-uuid' => $entity->uuid(),
+      'data-entity-embed-display' => 'entity_reference:entity_reference_entity_view',
+      'data-entity-embed-display-settings' => [],
+    ];
+
+    // If the data-entity-embed-display-settings isn't an array reset  it,
+    // otherwise we'll encounter a fatal error when calling
+    // $this->buildEntityEmbedDisplayPlugin() further down the line.
+    if (!is_array($context['data-entity-embed-display-settings'])) {
+      \Drupal::logger('entity_embed')->warning('Invalid display settings encountered. Could not process following settings for entity type "@entity_type" with the uuid "@uuid": @settings', [
+        '@settings' => $context['data-entity-embed-display-settings'],
+        '@entity_type' => $entity->getEntityTypeId(),
+        '@uuid' => $entity->uuid(),
+      ]);
+      $context['data-entity-embed-display-settings'] = [];
+    }
+
+    // The default Entity Embed Display plugin has been deprecated by the
+    // rendered entity field formatter.
+    if ($context['data-entity-embed-display'] === 'default') {
+      $context['data-entity-embed-display'] = 'entity_reference:entity_reference_entity_view';
+    }
+
+    // The caption text is double-encoded, so decode it here.
+    if (isset($context['data-caption'])) {
+      $context['data-caption'] = Html::decodeEntities($context['data-caption']);
+    }
+
+    // Allow modules to alter the entity prior to embed rendering.
+    $this->moduleHandler->alter(["{$context['data-entity-type']}_embed_context", 'entity_embed_context'], $context, $entity);
+
+    // Build and render the Entity Embed Display plugin, allowing modules to
+    // alter the result before rendering.
+    $build = [
+      '#theme_wrappers' => ['entity_embed_container'],
+      '#entity' => $entity,
+      '#context' => $context,
+    ];
+    $build['entity'] = $this->buildEntityEmbedDisplayPlugin(
+      $entity,
+      $context['data-entity-embed-display'],
+      $context['data-entity-embed-display-settings'],
+      $context
+    );
+    // Don't ever cache a representation of an embedded entity, since the host
+    // entity may be overriding specific values (such as an `alt` attribute)
+    // which means that this particular rendered representation is unique to
+    // the host entity, and hence nonsensical to cache separately anyway.
+    unset($build['entity']['#cache']['keys']);
+
+    if (isset($context['class'])) {
+      if (is_string($context['class'])) {
+        $context['class'] = explode(' ', $context['class']);
+      }
+    }
+    else {
+      $context['class'] = [];
+    }
+    $context['class'][] = 'embedded-entity';
+
+    // Maintain data- attributes.
+    if (isset($context)) {
+      $build['#attributes'] = $context;
+    }
+
+    // Make sure that access to the entity is respected.
+    $build['#access'] = $entity->access('view', NULL, TRUE);
+
+    // @todo Should this hook get invoked if $build is an empty array?
+    $this->moduleHandler->alter(["{$context['data-entity-type']}_embed", 'entity_embed'], $build, $entity, $context);
+    return $build;
+  }
+
+  /**
+   * Builds the render array for an entity using an Entity Embed Display plugin.
+   *
+   * @param \Drupal\Core\Entity\EntityInterface $entity
+   *   The entity to be rendered.
+   * @param string $plugin_id
+   *   The Entity Embed Display plugin ID.
+   * @param array $plugin_configuration
+   *   (optional) Array of plugin configuration values.
+   * @param array $context
+   *   (optional) Array of additional context values, usually the embed HTML
+   *   tag's attributes.
+   *
+   * @return array
+   *   A render array for the Entity Embed Display plugin.
+   */
+  protected function buildEntityEmbedDisplayPlugin(EntityInterface $entity, $plugin_id, array $plugin_configuration = [], array $context = []) {
+    // Build the Entity Embed Display plugin.
+    /** @var \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayBase $display */
+    $display = $this->displayPluginManager->createInstance($plugin_id, $plugin_configuration);
+    $display->setContextValue('entity', $entity);
+    $display->setAttributes($context);
+
+    // Check if the Entity Embed Display plugin is accessible. This also checks
+    // entity access, which is why we never call $entity->access() here.
+    if (!$display->access()) {
+      return [];
+    }
+
+    return $display->build();
+  }
+
+}
diff -ruN a/src/EntityEmbedBuilderInterface.php b/src/EntityEmbedBuilderInterface.php
--- a/src/EntityEmbedBuilderInterface.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/EntityEmbedBuilderInterface.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,30 @@
+<?php
+
+namespace Drupal\entity_embed;
+
+use Drupal\Core\Entity\EntityInterface;
+
+/**
+ * Defines services that are responsible for building of embedded entities.
+ *
+ * @internal
+ */
+interface EntityEmbedBuilderInterface {
+
+  /**
+   * Builds the render array for an embedded entity.
+   *
+   * @param \Drupal\Core\Entity\EntityInterface $entity
+   *   The entity to be rendered.
+   * @param array $context
+   *   (optional) Array of context values, corresponding to the attributes on
+   *   the embed HTML tag.
+   *
+   * @return array
+   *   A render array.
+   *
+   * @todo improve documentation
+   */
+  public function buildEntityEmbed(EntityInterface $entity, array $context = []);
+
+}
diff -ruN a/src/EntityEmbedDisplay/EntityEmbedDisplayBase.php b/src/EntityEmbedDisplay/EntityEmbedDisplayBase.php
--- a/src/EntityEmbedDisplay/EntityEmbedDisplayBase.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/EntityEmbedDisplay/EntityEmbedDisplayBase.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,354 @@
+<?php
+
+namespace Drupal\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Component\Utility\NestedArray;
+use Drupal\Core\Access\AccessResult;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Language\LanguageInterface;
+use Drupal\Core\Language\LanguageManagerInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Drupal\Core\Plugin\PluginBase;
+use Drupal\Core\Session\AccountInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Defines a base Entity Embed Display implementation.
+ *
+ * @see \Drupal\entity_embed\Annotation\EntityEmbedDisplay
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+ * @see plugin_api
+ *
+ * @ingroup entity_embed_api
+ */
+abstract class EntityEmbedDisplayBase extends PluginBase implements ContainerFactoryPluginInterface, EntityEmbedDisplayInterface {
+
+  /**
+   * The entity type manager service.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The language manager.
+   *
+   * @var \Drupal\Core\Language\LanguageManagerInterface
+   */
+  protected $languageManager;
+
+  /**
+   * The context for the plugin.
+   *
+   * @var array
+   */
+  public $context = [];
+
+  /**
+   * The attributes on the embedded entity.
+   *
+   * @var array
+   */
+  public $attributes = [];
+
+  /**
+   * Constructs an EntityEmbedDisplayBase object.
+   *
+   * @param array $configuration
+   *   A configuration array containing information about the plugin instance.
+   * @param string $plugin_id
+   *   The plugin_id for the plugin instance.
+   * @param mixed $plugin_definition
+   *   The plugin implementation definition.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager service.
+   * @param \Drupal\Core\Language\LanguageManagerInterface $language_manager
+   *   The language manager.
+   */
+  public function __construct(array $configuration, $plugin_id, $plugin_definition, EntityTypeManagerInterface $entity_type_manager, LanguageManagerInterface $language_manager) {
+    parent::__construct($configuration, $plugin_id, $plugin_definition);
+    $this->setConfiguration($configuration);
+    $this->entityTypeManager = $entity_type_manager;
+    $this->languageManager = $language_manager;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $configuration,
+      $plugin_id,
+      $plugin_definition,
+      $container->get('entity_type.manager'),
+      $container->get('language_manager')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function access(AccountInterface $account = NULL) {
+    // @todo Add a hook_entity_embed_display_access()?
+    // Check that the plugin's registered entity types matches the current
+    // entity type.
+    return AccessResult::allowedIf($this->isValidEntityType())
+      // @see \Drupal\Core\Entity\EntityTypeManager
+      ->addCacheTags(['entity_types']);
+  }
+
+  /**
+   * Validates that this display plugin applies to the current entity type.
+   *
+   * This checks the plugin annotation's 'entity_types' value, which should be
+   * an array of entity types that this plugin can process, or FALSE if the
+   * plugin applies to all entity types.
+   *
+   * @return bool
+   *   TRUE if the plugin can display the current entity type, or FALSE
+   *   otherwise.
+   */
+  protected function isValidEntityType() {
+    // First, determine whether or not the entity type id is valid. Return FALSE
+    // if the specified id is not valid.
+    $entity_type = $this->getEntityTypeFromContext();
+    if (!$this->entityTypeManager->getDefinition($entity_type)) {
+      return FALSE;
+    }
+
+    $definition = $this->getPluginDefinition();
+    if ($definition['entity_types'] === FALSE) {
+      return TRUE;
+    }
+    else {
+      return in_array($entity_type, $definition['entity_types']);
+    }
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  abstract public function build();
+
+  /**
+   * {@inheritdoc}
+   */
+  public function calculateDependencies() {
+    return [];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function defaultConfiguration() {
+    return [];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getConfiguration() {
+    return $this->configuration;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setConfiguration(array $configuration) {
+    $this->configuration = NestedArray::mergeDeep(
+      $this->defaultConfiguration(),
+      $configuration
+    );
+    return $this;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    return $form;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function validateConfigurationForm(array &$form, FormStateInterface $form_state) {
+    // Do nothing.
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
+    if (!$form_state->getErrors()) {
+      $this->configuration = array_intersect_key($form_state->getValues(), $this->defaultConfiguration());
+    }
+  }
+
+  /**
+   * Gets a configuration value.
+   *
+   * @param string $name
+   *   The name of the plugin configuration value.
+   * @param mixed $default
+   *   The default value to return if the configuration value does not exist.
+   *
+   * @return mixed
+   *   The currently set configuration value, or the value of $default if the
+   *   configuration value is not set.
+   */
+  public function getConfigurationValue($name, $default = NULL) {
+    $configuration = $this->getConfiguration();
+    return array_key_exists($name, $configuration) ? $configuration[$name] : $default;
+  }
+
+  /**
+   * Sets the value for a defined context.
+   *
+   * @param string $name
+   *   The name of the context in the plugin definition.
+   * @param mixed $value
+   *   The value to set the context to. The value has to validate against the
+   *   provided context definition.
+   */
+  public function setContextValue($name, $value) {
+    $this->context[$name] = $value;
+  }
+
+  /**
+   * Gets the values for all defined contexts.
+   *
+   * @return array
+   *   An array of set context values, keyed by context name.
+   */
+  public function getContextValues() {
+    return $this->context;
+  }
+
+  /**
+   * Gets the value for a defined context.
+   *
+   * @param string $name
+   *   The name of the context in the plugin configuration.
+   *
+   * @return mixed
+   *   The currently set context value.
+   */
+  public function getContextValue($name) {
+    return !empty($this->context[$name]) ? $this->context[$name] : NULL;
+  }
+
+  /**
+   * Returns whether or not value is set for a defined context.
+   *
+   * @param string $name
+   *   The name of the context in the plugin configuration.
+   *
+   * @return bool
+   *   True if context value exists, false otherwise.
+   */
+  public function hasContextValue($name) {
+    return array_key_exists($name, $this->context);
+  }
+
+  /**
+   * Gets the entity type from the current context.
+   *
+   * @return string
+   *   The entity type id.
+   */
+  public function getEntityTypeFromContext() {
+    if ($this->hasContextValue('entity')) {
+      return $this->getContextValue('entity')->getEntityTypeId();
+    }
+    else {
+      return $this->getContextValue('entity_type');
+    }
+  }
+
+  /**
+   * Gets the entity from the current context.
+   *
+   * @todo Where does this come from? The value must come from somewhere, yet
+   * this does not implement any context-related interfaces. This is an *input*,
+   * so we need cache contexts and possibly cache tags to reflect where this
+   * came from. We need that for *everything* that this class does that relies
+   * on this, plus any of its subclasses. Right now, this is effectively a
+   * global that breaks cacheability metadata.
+   *
+   * @return \Drupal\Core\Entity\EntityInterface
+   *   The entity from the current context.
+   */
+  public function getEntityFromContext() {
+    if ($this->hasContextValue('entity')) {
+      return $this->getContextValue('entity');
+    }
+  }
+
+  /**
+   * Sets the values for all attributes.
+   *
+   * @param array $attributes
+   *   An array of attributes, keyed by attribute name.
+   */
+  public function setAttributes(array $attributes) {
+    $this->attributes = $attributes;
+  }
+
+  /**
+   * Gets the values for all attributes.
+   *
+   * @return array
+   *   An array of set attribute values, keyed by attribute name.
+   */
+  public function getAttributeValues() {
+    return $this->attributes;
+  }
+
+  /**
+   * Gets the value for an attribute.
+   *
+   * @param string $name
+   *   The name of the attribute.
+   * @param mixed $default
+   *   The default value to return if the attribute value does not exist.
+   *
+   * @return mixed
+   *   The currently set attribute value.
+   */
+  public function getAttributeValue($name, $default = NULL) {
+    $attributes = $this->getAttributeValues();
+    return array_key_exists($name, $attributes) ? $attributes[$name] : $default;
+  }
+
+  /**
+   * Checks if an attribute is set.
+   *
+   * @param string $name
+   *   The name of the attribute.
+   *
+   * @return bool
+   *   Returns TRUE if value is set.
+   */
+  public function hasAttribute($name) {
+    return array_key_exists($name, $this->getAttributeValues());
+  }
+
+  /**
+   * Gets the current language code.
+   *
+   * @return string
+   *   The langcode present in the 'data-langcode', if present, or the current
+   *   langcode from the language manager, otherwise.
+   */
+  public function getLangcode() {
+    $langcode = $this->getAttributeValue('data-langcode');
+    if (empty($langcode)) {
+      $langcode = $this->languageManager->getCurrentLanguage(LanguageInterface::TYPE_CONTENT)->getId();
+    }
+    return $langcode;
+  }
+
+}
diff -ruN a/src/EntityEmbedDisplay/EntityEmbedDisplayInterface.php b/src/EntityEmbedDisplay/EntityEmbedDisplayInterface.php
--- a/src/EntityEmbedDisplay/EntityEmbedDisplayInterface.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/EntityEmbedDisplay/EntityEmbedDisplayInterface.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,70 @@
+<?php
+
+namespace Drupal\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Component\Plugin\PluginInspectionInterface;
+use Drupal\Core\Plugin\PluginFormInterface;
+use Drupal\Core\Session\AccountInterface;
+use Drupal\Component\Plugin\ConfigurableInterface;
+use Drupal\Component\Plugin\DependentPluginInterface;
+
+/**
+ * Defines the interface for Entity Embed Display plugins.
+ *
+ * The abstraction layer provided by this plugin type may seem unnecessary at
+ * first sight. Why not just allow users of Entity Embed to choose a view mode
+ * (and its corresponding bundle-specific view display)?
+ *
+ * There are two reasons:
+ * - It may be necessary to have metadata (a description for example) that is
+ *   specific to a particular instance of embedding an entity. You may reference
+ *   the same entity many times, but each time you want different metadata (a
+ *   different description). If Entity Embed only allowed one to embed using a
+ *   particular view mode, this would not be possible, since every embed would
+ *   need to be rendered exactly the same.
+ * - Some entities can not be rendered by default because they do not have a
+ *   view builder. (particularly: the File entity which is crucial for embedding
+ *   of media). To still be able to embed them, an Entity Embed Display plugin
+ *   can be provided.
+ *
+ * @see \Drupal\Core\Entity\Entity\EntityViewMode
+ * @see \Drupal\Core\Entity\Entity\EntityViewDisplay
+ * @see \Drupal\Core\Entity\EntityViewBuilderInterface
+ *
+ * The ability to embed an entity using a view mode/display is then just one of
+ * many Entity Embed Display plugins. It is available for all entities that can
+ * be rendered (that have a view builder).
+ *
+ * @see \Drupal\entity_embed\Annotation\EntityEmbedDisplay
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayBase
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+ * @see plugin_api
+ *
+ * @ingroup entity_embed_api
+ */
+interface EntityEmbedDisplayInterface extends ConfigurableInterface, DependentPluginInterface, PluginFormInterface, PluginInspectionInterface {
+
+  /**
+   * Indicates whether this Entity Embed display can be used.
+   *
+   * This method allows base implementations to add general access restrictions
+   * that should apply to all extending Entity Embed display plugins.
+   *
+   * @param \Drupal\Core\Session\AccountInterface $account
+   *   (optional) The user for which to check access, or NULL to check access
+   *   for the current user. Defaults to NULL.
+   *
+   * @return \Drupal\Core\Access\AccessResultInterface
+   *   The access result.
+   */
+  public function access(AccountInterface $account = NULL);
+
+  /**
+   * Builds the renderable array for this Entity Embed display plugin.
+   *
+   * @return array
+   *   A renderable array representing the content of the embedded entity.
+   */
+  public function build();
+
+}
diff -ruN a/src/EntityEmbedDisplay/EntityEmbedDisplayManager.php b/src/EntityEmbedDisplay/EntityEmbedDisplayManager.php
--- a/src/EntityEmbedDisplay/EntityEmbedDisplayManager.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/EntityEmbedDisplay/EntityEmbedDisplayManager.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,189 @@
+<?php
+
+namespace Drupal\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Cache\CacheBackendInterface;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\Core\Plugin\DefaultPluginManager;
+use Drupal\Component\Plugin\Exception\PluginException;
+use Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay\MediaImageDecorator;
+
+/**
+ * Provides an Entity Embed display plugin manager.
+ *
+ * @see \Drupal\entity_embed\Annotation\EntityEmbedDisplay
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayBase
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ * @see plugin_api
+ */
+class EntityEmbedDisplayManager extends DefaultPluginManager {
+
+  /**
+   * Constructs a new EntityEmbedDisplayManager.
+   *
+   * @param \Traversable $namespaces
+   *   An object that implements \Traversable which contains the root paths
+   *   keyed by the corresponding namespace to look for plugin implementations.
+   * @param \Drupal\Core\Cache\CacheBackendInterface $cache_backend
+   *   Cache backend instance to use.
+   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   *   The module handler to invoke the alter hook with.
+   */
+  public function __construct(\Traversable $namespaces, CacheBackendInterface $cache_backend, ModuleHandlerInterface $module_handler) {
+    parent::__construct('Plugin/entity_embed/EntityEmbedDisplay', $namespaces, $module_handler, 'Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface', 'Drupal\entity_embed\Annotation\EntityEmbedDisplay');
+    $this->alterInfo('entity_embed_display_plugins');
+    // @todo Move the cache tag to the derivers once https://www.drupal.org/node/3001284 lands.
+    $this->setCacheBackend($cache_backend, 'entity_embed_display_plugins', ['config:entity_view_mode_list']);
+  }
+
+  /**
+   * Determines plugins whose constraints are satisfied by a set of contexts.
+   *
+   * @param array $contexts
+   *   An array of contexts.
+   *
+   * @return array
+   *   An array of plugin definitions.
+   *
+   * @todo At some point convert this to use ContextAwarePluginManagerTrait
+   *
+   * @see https://drupal.org/node/2277981
+   */
+  public function getDefinitionsForContexts(array $contexts = []) {
+    $definitions = $this->getDefinitions();
+
+    if (!empty($contexts['embed_button'])) {
+      $button_plugins = $contexts['embed_button']->getTypeSetting('display_plugins');
+      if (!empty($button_plugins)) {
+        $allowed_definitions = [];
+        foreach ($button_plugins as $plugin_id) {
+          if (!empty($definitions[$plugin_id])) {
+            $allowed_definitions[$plugin_id] = $definitions[$plugin_id];
+          }
+        }
+        $definitions = $allowed_definitions;
+      }
+    }
+
+    $valid_ids = array_filter(array_keys($definitions), function ($id) use ($contexts) {
+      try {
+        $display = $this->createInstance($id);
+        foreach ($contexts as $name => $value) {
+          $display->setContextValue($name, $value);
+        }
+        // We lose cacheability metadata at this point. We should refactor to
+        // avoid this. @see https://www.drupal.org/node/2593379#comment-11368447
+        return $display->access()->isAllowed();
+      }
+      catch (PluginException $e) {
+        return FALSE;
+      }
+    });
+    $definitions_for_context = array_intersect_key($definitions, array_flip($valid_ids));
+    $this->moduleHandler->alter('entity_embed_display_plugins_for_context', $definitions_for_context, $contexts);
+    return $definitions_for_context;
+  }
+
+  /**
+   * Gets definition options for context.
+   *
+   * Provides a list of plugins that can be used for a certain context and
+   * filters out plugins that should be hidden in the UI.
+   *
+   * @param array $context
+   *   An array of context options; possible keys are 'entity', 'entity_type'
+   *   and 'embed_button'.
+   *
+   * @return string[]
+   *   An array of valid plugin labels, keyed by plugin ID.
+   */
+  public function getDefinitionOptionsForContext(array $context) {
+    $values = [
+      'entity' => TRUE,
+      'entity_type' => TRUE,
+      'embed_button' => TRUE,
+    ];
+    assert(empty(array_diff_key($context, $values)));
+    $definitions = $this->getDefinitionsForContexts($context);
+    $definitions = $this->filterExposedDefinitions($definitions);
+    $options = array_map(function ($definition) {
+      return (string) $definition['label'];
+    }, $definitions);
+    natsort($options);
+    return $options;
+  }
+
+  /**
+   * Gets definition options for entity.
+   *
+   * Provides a list of plugins that can be used for a certain entity and
+   * filters out plugins that should be hidden in the UI.
+   *
+   * @param \Drupal\Core\Entity\EntityInterface $entity
+   *   An entity object.
+   *
+   * @return array
+   *   An array of valid plugin labels, keyed by plugin ID.
+   */
+  public function getDefinitionOptionsForEntity(EntityInterface $entity) {
+    $definitions = $this->getDefinitionsForContexts(['entity' => $entity, 'entity_type' => $entity->getEntityTypeId()]);
+    $definitions = $this->filterExposedDefinitions($definitions);
+    return array_map(function ($definition) {
+      return (string) $definition['label'];
+    }, $definitions);
+  }
+
+  /**
+   * Filters out plugins from definitions that should be hidden in the UI.
+   *
+   * @param array $definitions
+   *   The array of plugin definitions.
+   *
+   * @return array
+   *   Returns plugin definitions that should be displayed in the UI.
+   */
+  protected function filterExposedDefinitions(array $definitions) {
+    return array_filter($definitions, function ($definition) {
+      return empty($definition['no_ui']);
+    });
+  }
+
+  /**
+   * Gets definition options for entity type.
+   *
+   * Provides a list of plugins that can be used for a certain entity type and
+   * filters out plugins that should be hidden in the UI.
+   *
+   * @param string $entity_type
+   *   The entity type id.
+   *
+   * @return array
+   *   An array of valid plugin labels, keyed by plugin ID.
+   */
+  public function getDefinitionOptionsForEntityType($entity_type) {
+    $definitions = $this->getDefinitionsForContexts(['entity_type' => $entity_type]);
+    $definitions = $this->filterExposedDefinitions($definitions);
+    return array_map(function ($definition) {
+      return (string) $definition['label'];
+    }, $definitions);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function createInstance($plugin_id, array $configuration = []) {
+    $instance = parent::createInstance($plugin_id, $configuration);
+    $definition = $instance->getPluginDefinition();
+
+    if (empty($definition['supports_image_alt_and_title'])) {
+      return $instance;
+    }
+    else {
+      // Use decorator pattern to add alt and title fields to dialog when
+      // embedding media with image source.
+      return new MediaImageDecorator($instance);
+    }
+  }
+
+}
diff -ruN a/src/EntityEmbedDisplay/FieldFormatterEntityEmbedDisplayBase.php b/src/EntityEmbedDisplay/FieldFormatterEntityEmbedDisplayBase.php
--- a/src/EntityEmbedDisplay/FieldFormatterEntityEmbedDisplayBase.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/EntityEmbedDisplay/FieldFormatterEntityEmbedDisplayBase.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,236 @@
+<?php
+
+namespace Drupal\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Access\AccessResult;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Field\BaseFieldDefinition;
+use Drupal\Core\Field\FormatterPluginManager;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Language\LanguageManagerInterface;
+use Drupal\Core\Plugin\PluginDependencyTrait;
+use Drupal\Core\Session\AccountInterface;
+use Drupal\Core\TypedData\TypedDataManager;
+use Drupal\entity_embed\Entity\EntityEmbedFakeEntity;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Base class for field formatter display plugins.
+ */
+abstract class FieldFormatterEntityEmbedDisplayBase extends EntityEmbedDisplayBase {
+  use PluginDependencyTrait;
+
+  /**
+   * The field formatter plugin manager.
+   *
+   * @var \Drupal\Core\Field\FormatterPluginManager
+   */
+  protected $formatterPluginManager;
+
+  /**
+   * The typed data manager.
+   *
+   * @var \Drupal\Core\TypedData\TypedDataManager
+   */
+  protected $typedDataManager;
+
+  /**
+   * The field definition.
+   *
+   * @var \Drupal\Core\Field\BaseFieldDefinition
+   */
+  protected $fieldDefinition;
+
+  /**
+   * The field formatter.
+   *
+   * @var \Drupal\Core\Field\FormatterInterface
+   */
+  protected $fieldFormatter;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    $instance = parent::create($container, $configuration, $plugin_id, $plugin_definition);
+    $instance->formatterPluginManager = $container->get('plugin.manager.field.formatter');
+    $instance->typedDataManager = $container->get('typed_data_manager');
+    return $instance;
+  }
+
+  /**
+   * Get the FieldDefinition object required to render this field's formatter.
+   *
+   * @return \Drupal\Core\Field\BaseFieldDefinition
+   *   The field definition.
+   *
+   * @see \Drupal\entity_embed\FieldFormatterEntityEmbedDisplayBase::build()
+   */
+  public function getFieldDefinition() {
+    if (!isset($this->fieldDefinition)) {
+      $field_type = $this->getPluginDefinition()['field_type'];
+      $this->fieldDefinition = BaseFieldDefinition::create($field_type);
+      // Ensure the field name is unique for each Entity Embed Display plugin
+      // instance.
+      static $index = 0;
+      $this->fieldDefinition->setName('_entity_embed_' . $index++);
+    }
+    return $this->fieldDefinition;
+  }
+
+  /**
+   * Get the field value required to pass into the field formatter.
+   *
+   * @return mixed
+   *   The field value.
+   */
+  abstract public function getFieldValue();
+
+  /**
+   * {@inheritdoc}
+   */
+  public function access(AccountInterface $account = NULL) {
+    return parent::access($account)->andIf($this->isApplicableFieldFormatter());
+  }
+
+  /**
+   * Checks if the field formatter is applicable.
+   *
+   * @return \Drupal\Core\Access\AccessResult
+   *   Returns the access result.
+   */
+  protected function isApplicableFieldFormatter() {
+    $definition = $this->formatterPluginManager()->getDefinition($this->getFieldFormatterId());
+    return AccessResult::allowedIf($definition['class']::isApplicable($this->getFieldDefinition()));
+  }
+
+  /**
+   * Returns the field formatter id.
+   *
+   * @return string|null
+   *   Returns field formatter id or null.
+   */
+  public function getFieldFormatterId() {
+    return $this->getDerivativeId();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function build() {
+    // Create a temporary entity to which our fake field value can be
+    // added.
+    $fakeEntity = EntityEmbedFakeEntity::create(['type' => '_entity_embed']);
+
+    $definition = $this->getFieldDefinition();
+
+    /* @var \Drupal\Core\Field\FieldItemListInterface $items $items */
+    // Create a field item list object, 1 is the value, array('target_id' => 1)
+    // would work too, or multiple values. 1 is passed down from the list to the
+    // field item, which knows that an integer is the ID.
+    $items = $this->typedDataManager->create(
+      $definition,
+      $this->getFieldValue($definition),
+      $definition->getName(),
+      $fakeEntity->getTypedData()
+    );
+
+    // Prepare, expects an array of items, keyed by parent entity ID.
+    $formatter = $this->getFieldFormatter();
+    $formatter->prepareView([$fakeEntity->id() => $items]);
+    $build = $formatter->viewElements($items, $this->getLangcode());
+    // For some reason $build[0]['#printed'] is TRUE, which means it will fail
+    // to render later. So for now we manually fix that.
+    // @todo Investigate why this is needed.
+    show($build[0]);
+    return $build[0];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function defaultConfiguration() {
+    return $this->formatterPluginManager()->getDefaultSettings($this->getFieldFormatterId());
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    return $this->getFieldFormatter()->settingsForm($form, $form_state);
+  }
+
+  /**
+   * Constructs a field formatter.
+   *
+   * @return \Drupal\Core\Field\FormatterInterface
+   *   The formatter object.
+   */
+  public function getFieldFormatter() {
+    if (!isset($this->fieldFormatter)) {
+      $display = [
+        'type' => $this->getFieldFormatterId(),
+        'settings' => $this->getConfiguration(),
+        'label' => 'hidden',
+      ];
+
+      // Create the formatter plugin. Will use the default formatter for that
+      // field type if none is passed.
+      $this->fieldFormatter = $this->formatterPluginManager->getInstance(
+        [
+          'field_definition' => $this->getFieldDefinition(),
+          'view_mode' => '_entity_embed',
+          'configuration' => $display,
+        ]
+      );
+    }
+
+    return $this->fieldFormatter;
+  }
+
+  /**
+   * Creates a new faux-field definition.
+   *
+   * @param string $type
+   *   The type of the field.
+   *
+   * @return \Drupal\Core\Field\BaseFieldDefinition
+   *   A new field definition.
+   */
+  protected function createFieldDefinition($type) {
+    $definition = BaseFieldDefinition::create($type);
+    static $index = 0;
+    $definition->setName('_entity_embed_' . $index++);
+    return $definition;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function calculateDependencies() {
+    $this->addDependencies(parent::calculateDependencies());
+
+    $definition = $this->formatterPluginManager()->getDefinition($this->getFieldFormatterId());
+    $this->addDependency('module', $definition['provider']);
+    // @todo Investigate why this does not work currently.
+    // $this->calculatePluginDependencies($this->getFieldFormatter());
+    return $this->dependencies;
+  }
+
+  /**
+   * Gets the field formatter plugin manager.
+   *
+   * This is needed for the defaultConfiguration() method since that gets
+   * invoked via the constructor, and our services are injected after the
+   * constructor are called.
+   *
+   * @return \Drupal\Core\Field\FormatterPluginManager
+   */
+  public function formatterPluginManager() {
+    if (!isset($this->formatterPluginManager)) {
+      $this->formatterPluginManager = \Drupal::service('plugin.manager.field.formatter');
+    }
+    return $this->formatterPluginManager;
+  }
+
+}
diff -ruN a/src/Exception/EntityNotFoundException.php b/src/Exception/EntityNotFoundException.php
--- a/src/Exception/EntityNotFoundException.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Exception/EntityNotFoundException.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,8 @@
+<?php
+
+namespace Drupal\entity_embed\Exception;
+
+/**
+ * Exception thrown when the embedded entity cannot be loaded.
+ */
+class EntityNotFoundException extends \Exception {}
diff -ruN a/src/Exception/RecursiveRenderingException.php b/src/Exception/RecursiveRenderingException.php
--- a/src/Exception/RecursiveRenderingException.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Exception/RecursiveRenderingException.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,8 @@
+<?php
+
+namespace Drupal\entity_embed\Exception;
+
+/**
+ * Exception thrown when the embedded entity causes recursion when rendering.
+ */
+class RecursiveRenderingException extends \Exception {}
diff -ruN a/src/Form/EntityEmbedDialog.php b/src/Form/EntityEmbedDialog.php
--- a/src/Form/EntityEmbedDialog.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Form/EntityEmbedDialog.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,905 @@
+<?php
+
+namespace Drupal\entity_embed\Form;
+
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Ajax\AjaxResponse;
+use Drupal\Core\Ajax\CloseModalDialogCommand;
+use Drupal\Core\Ajax\HtmlCommand;
+use Drupal\Core\Ajax\SetDialogTitleCommand;
+use Drupal\Core\Entity\EntityFieldManagerInterface;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Entity\FieldableEntityInterface;
+use Drupal\Core\Entity\TranslatableInterface;
+use Drupal\Core\Extension\ModuleHandlerInterface;
+use Drupal\Core\Form\FormBase;
+use Drupal\Core\Form\FormBuilderInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\editor\Ajax\EditorDialogSave;
+use Drupal\editor\EditorInterface;
+use Drupal\embed\EmbedButtonInterface;
+use Drupal\entity_browser\Events\Events;
+use Drupal\entity_browser\Events\RegisterJSCallbacks;
+use Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager;
+use Drupal\Component\Serialization\Json;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Symfony\Component\EventDispatcher\EventDispatcherInterface;
+
+/**
+ * Provides a form to embed entities by specifying data attributes.
+ */
+class EntityEmbedDialog extends FormBase {
+
+  /**
+   * The entity embed display manager.
+   *
+   * @var \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+   */
+  protected $entityEmbedDisplayManager;
+
+  /**
+   * The form builder.
+   *
+   * @var \Drupal\Core\Form\FormBuilderInterface
+   */
+  protected $formBuilder;
+
+  /**
+   * The entity type manager service.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * Event dispatcher service.
+   *
+   * @var \Symfony\Component\EventDispatcher\EventDispatcherInterface
+   */
+  protected $eventDispatcher;
+
+  /**
+   * The entity browser.
+   *
+   * @var \Drupal\entity_browser\EntityBrowserInterface
+   */
+  protected $entityBrowser;
+
+  /**
+   * The entity field manager.
+   *
+   * @var \Drupal\Core\Entity\EntityFieldManager
+   */
+  protected $entityFieldManager;
+
+  /**
+   * The module handler service.
+   *
+   * @var \Drupal\Core\Extension\ModuleHandlerInterface
+   */
+  protected $moduleHandler;
+
+  /**
+   * The entity browser settings from the entity embed button.
+   *
+   * @var array
+   */
+  protected $entityBrowserSettings = [];
+
+  /**
+   * Constructs a EntityEmbedDialog object.
+   *
+   * @param \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager $entity_embed_display_manager
+   *   The Module Handler.
+   * @param \Drupal\Core\Form\FormBuilderInterface $form_builder
+   *   The Form Builder.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager service.
+   * @param \Symfony\Component\EventDispatcher\EventDispatcherInterface $event_dispatcher
+   *   Event dispatcher service.
+   * @param \Drupal\Core\Entity\EntityFieldManagerInterface $entity_field_manager
+   *   The entity field manager.
+   * @param \Drupal\Core\Extension\ModuleHandlerInterface $module_handler
+   *   The module handler.
+   */
+  public function __construct(EntityEmbedDisplayManager $entity_embed_display_manager, FormBuilderInterface $form_builder, EntityTypeManagerInterface $entity_type_manager, EventDispatcherInterface $event_dispatcher, EntityFieldManagerInterface $entity_field_manager, ModuleHandlerInterface $module_handler) {
+    $this->entityEmbedDisplayManager = $entity_embed_display_manager;
+    $this->formBuilder = $form_builder;
+    $this->entityTypeManager = $entity_type_manager;
+    $this->eventDispatcher = $event_dispatcher;
+    $this->entityFieldManager = $entity_field_manager;
+    $this->moduleHandler = $module_handler;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    return new static(
+      $container->get('plugin.manager.entity_embed.display'),
+      $container->get('form_builder'),
+      $container->get('entity_type.manager'),
+      $container->get('event_dispatcher'),
+      $container->get('entity_field.manager'),
+      $container->get('module_handler')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFormId() {
+    return 'entity_embed_dialog';
+  }
+
+  /**
+   * Loads an entity (in the appropriate translation) given HTML attributes.
+   *
+   * @param string[] $attributes
+   *   An array of HTML attributes, including at least `data-entity-type` and
+   *   `data-entity-uuid`, and optionally `data-langcode`.
+   *
+   * @return \Drupal\Core\Entity\EntityInterface|null
+   *   The requested entity, or NULL.
+   */
+  protected function loadEntityByAttributes(array $attributes) {
+    $entity = $this->entityTypeManager->getStorage($attributes['data-entity-type'])
+      ->loadByProperties(['uuid' => $attributes['data-entity-uuid']]);
+    $entity = current($entity);
+    if ($entity && $entity instanceof TranslatableInterface && !empty($attributes['data-langcode'])) {
+      if ($entity->hasTranslation($attributes['data-langcode'])) {
+        $entity = $entity->getTranslation($attributes['data-langcode']);
+      }
+    }
+
+    return $entity;
+  }
+
+  /**
+   * Form constructor.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The current state of the form.
+   * @param \Drupal\editor\EditorInterface $editor
+   *   The editor to which this dialog corresponds.
+   * @param \Drupal\embed\EmbedButtonInterface $embed_button
+   *   The URL button to which this dialog corresponds.
+   */
+  public function buildForm(array $form, FormStateInterface $form_state, EditorInterface $editor = NULL, EmbedButtonInterface $embed_button = NULL) {
+    $values = $form_state->getValues();
+    $input = $form_state->getUserInput();
+    // Set embed button element in form state, so that it can be used later in
+    // validateForm() function.
+    $form_state->set('embed_button', $embed_button);
+    $form_state->set('editor', $editor);
+    // Initialize entity element with form attributes, if present.
+    $entity_element = empty($values['attributes']) ? [] : $values['attributes'];
+    $entity_element += empty($input['attributes']) ? [] : $input['attributes'];
+    // The default values are set directly from \Drupal::request()->request,
+    // provided by the editor plugin opening the dialog.
+    if (!$form_state->get('entity_element')) {
+      $form_state->set('entity_element', isset($input['editor_object']) ? $input['editor_object'] : []);
+    }
+    $entity_element += $form_state->get('entity_element');
+    $entity_element += [
+      'data-entity-type' => $embed_button->getTypeSetting('entity_type'),
+      'data-entity-uuid' => '',
+      'data-entity-embed-display' => 'entity_reference:entity_reference_entity_view',
+      'data-entity-embed-display-settings' => isset($form_state->get('entity_element')['data-entity-embed-settings']) ? $form_state->get('entity_element')['data-entity-embed-settings'] : [],
+    ];
+    $form_state->set('entity_element', $entity_element);
+    $entity = $this->loadEntityByAttributes($entity_element);
+    $form_state->set('entity', $entity ?: NULL);
+
+    if (!$form_state->get('step')) {
+      // If an entity has been selected, then always skip to the embed options.
+      if ($form_state->get('entity')) {
+        $form_state->set('step', 'embed');
+      }
+      else {
+        $form_state->set('step', 'select');
+      }
+    }
+
+    $form['#tree'] = TRUE;
+    $form['#attached']['library'][] = 'editor/drupal.editor.dialog';
+    $form['#attached']['library'][] = 'entity_embed/drupal.entity_embed.dialog';
+    $form['#prefix'] = '<div id="entity-embed-dialog-form">';
+    $form['#suffix'] = '</div>';
+    $form['#attributes']['class'][] = 'entity-embed-dialog-step--' . $form_state->get('step');
+
+    $this->loadEntityBrowser($form_state);
+
+    if ($form_state->get('step') == 'select') {
+      $form = $this->buildSelectStep($form, $form_state);
+    }
+    elseif ($form_state->get('step') == 'review') {
+      $form = $this->buildReviewStep($form, $form_state);
+    }
+    elseif ($form_state->get('step') == 'embed') {
+      $form = $this->buildEmbedStep($form, $form_state);
+    }
+
+    return $form;
+  }
+
+  /**
+   * Form constructor for the entity selection step.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The current state of the form.
+   *
+   * @return array
+   *   The form structure.
+   */
+  public function buildSelectStep(array $form, FormStateInterface $form_state) {
+    // Entity element is calculated on every AJAX request/submit.
+    // See self::buildForm().
+    $entity_element = $form_state->get('entity_element');
+    /** @var \Drupal\embed\EmbedButtonInterface $embed_button */
+    $embed_button = $form_state->get('embed_button');
+    $entity = $form_state->get('entity');
+
+    $form['attributes']['data-entity-type'] = [
+      '#type' => 'value',
+      '#value' => $entity_element['data-entity-type'],
+    ];
+
+    $label = $this->t('Label');
+    // Attempt to display a better label if we can by getting it from
+    // the label field definition.
+    $entity_type = $this->entityTypeManager->getDefinition($entity_element['data-entity-type']);
+    if ($entity_type->entityClassImplements(FieldableEntityInterface::class) && $entity_type->hasKey('label')) {
+      $field_definitions = $this->entityFieldManager->getBaseFieldDefinitions($entity_type->id());
+      if (isset($field_definitions[$entity_type->getKey('label')])) {
+        $label = $field_definitions[$entity_type->getKey('label')]->getLabel();
+      }
+    }
+
+    $form['#title'] = $this->t('Select @type to embed', ['@type' => $entity_type->getSingularLabel()]);
+
+    if ($this->entityBrowser) {
+      $this->eventDispatcher->addListener(Events::REGISTER_JS_CALLBACKS, [$this, 'registerJSCallback']);
+      $form['entity_browser'] = [
+        '#type' => 'entity_browser',
+        '#entity_browser' => $this->entityBrowser->id(),
+        '#cardinality' => 1,
+        '#entity_browser_validators' => [
+          'entity_type' => ['type' => $entity_element['data-entity-type']],
+        ],
+      ];
+    }
+    else {
+      $form['entity_id'] = [
+        '#type' => 'entity_autocomplete',
+        '#target_type' => $entity_element['data-entity-type'],
+        '#title' => $label,
+        '#default_value' => $entity,
+        '#required' => TRUE,
+        '#description' => $this->t('Type label and pick the right one from suggestions. Note that the unique ID will be saved.'),
+        '#maxlength' => 255,
+      ];
+      if ($bundles = $embed_button->getTypeSetting('bundles')) {
+        $form['entity_id']['#selection_settings']['target_bundles'] = $bundles;
+      }
+    }
+
+    if (!empty($entity_element['data-langcode'])) {
+      $form['attributes']['data-langcode'] = [
+        '#type' => 'hidden',
+        '#value' => $entity_element['data-langcode'],
+      ];
+    }
+
+    $form['attributes']['data-entity-uuid'] = [
+      '#type' => 'value',
+      '#title' => $entity_element['data-entity-uuid'],
+    ];
+    $form['actions'] = [
+      '#type' => 'actions',
+    ];
+
+    $form['actions']['save_modal'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Next'),
+      '#button_type' => 'primary',
+      // No regular submit-handler. This form only works via JavaScript.
+      '#submit' => [],
+      '#ajax' => [
+        'callback' => '::submitSelectStep',
+        'event' => 'click',
+      ],
+      '#attributes' => [
+        'class' => [
+          'js-button-next',
+        ],
+      ],
+    ];
+
+    return $form;
+  }
+
+  /**
+   * Form constructor for the entity review step.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The current state of the form.
+   *
+   * @return array
+   *   The form structure.
+   */
+  public function buildReviewStep(array $form, FormStateInterface $form_state) {
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = $form_state->get('entity');
+
+    $form['#title'] = $this->t('Review selected @type', ['@type' => $entity->getEntityType()->getSingularLabel()]);
+
+    $form['selection'] = [
+      '#markup' => $entity->label(),
+    ];
+
+    $form['actions'] = [
+      '#type' => 'actions',
+    ];
+
+    $form['actions']['back'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Replace selection'),
+      // No regular submit-handler. This form only works via JavaScript.
+      '#submit' => [],
+      '#ajax' => [
+        'callback' => '::submitAndShowSelect',
+        'event' => 'click',
+      ],
+    ];
+
+    $form['actions']['save_modal'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Next'),
+      '#button_type' => 'primary',
+      // No regular submit-handler. This form only works via JavaScript.
+      '#submit' => [],
+      '#ajax' => [
+        'callback' => '::submitAndShowEmbed',
+        'event' => 'click',
+      ],
+      '#attributes' => [
+        'class' => [
+          'js-button-next',
+        ],
+      ],
+    ];
+
+    return $form;
+  }
+
+  /**
+   * Form constructor for the entity embedding step.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The current state of the form.
+   *
+   * @return array
+   *   The form structure.
+   */
+  public function buildEmbedStep(array $form, FormStateInterface $form_state) {
+    // Entity element is calculated on every AJAX request/submit.
+    // See self::buildForm().
+    $entity_element = $form_state->get('entity_element');
+    /** @var \Drupal\embed\EmbedButtonInterface $embed_button */
+    $embed_button = $form_state->get('embed_button');
+    /** @var \Drupal\editor\EditorInterface $editor */
+    $editor = $form_state->get('editor');
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = $form_state->get('entity');
+    $values = $form_state->getValues();
+
+    $form['#title'] = $this->t('Embed @type', ['@type' => $entity->getEntityType()->getSingularLabel()]);
+
+    try {
+      if ($entity->getEntityType()->hasLinkTemplate('canonical')) {
+        $options = [
+          'attributes' => [
+            'target' => '_blank',
+          ],
+        ];
+        $entity_label = $entity->toLink($entity->label(), 'canonical', $options)->toString();
+      }
+      elseif ($entity->getEntityTypeId() == 'file') {
+        $entity_label = '<a href="' . file_create_url($entity->getFileUri()) . '" target="_blank">' . $entity->label() . '</a>';
+      }
+      else {
+        $entity_label = '<a href="' . $entity->toUrl()->toString() . '" target="_blank">' . $entity->label() . '</a>';
+      }
+    }
+    catch (\Exception $e) {
+      $entity_label = $entity->label();
+    }
+
+    $form['entity'] = [
+      '#type' => 'item',
+      '#title' => $this->t('Selected entity'),
+      '#markup' => $entity_label,
+    ];
+    $form['attributes']['data-entity-type'] = [
+      '#type' => 'hidden',
+      '#value' => $entity_element['data-entity-type'],
+    ];
+    $form['attributes']['data-entity-uuid'] = [
+      '#type' => 'hidden',
+      '#value' => $entity_element['data-entity-uuid'],
+    ];
+
+    if (!empty($entity_element['data-langcode'])) {
+      $form['attributes']['data-langcode'] = [
+        '#type' => 'hidden',
+        '#value' => $entity_element['data-langcode'],
+      ];
+    }
+
+    // Build the list of allowed Entity Embed Display plugins.
+    $display_plugin_options = $this->getDisplayPluginOptions($embed_button, $entity);
+
+    // If the currently selected display is not in the available options,
+    // use the first from the list instead. This can happen if an alter
+    // hook customizes the list based on the entity.
+    if (!isset($display_plugin_options[$entity_element['data-entity-embed-display']])) {
+      $entity_element['data-entity-embed-display'] = key($display_plugin_options);
+    }
+
+    // The default Entity Embed Display plugin has been deprecated by the
+    // rendered entity field formatter.
+    if ($entity_element['data-entity-embed-display'] === 'default') {
+      $entity_element['data-entity-embed-display'] = 'entity_reference:entity_reference_entity_view';
+    }
+
+    $form['attributes']['data-entity-embed-display'] = [
+      '#type' => 'select',
+      '#title' => $this->t('Display as'),
+      '#options' => $display_plugin_options,
+      '#default_value' => $entity_element['data-entity-embed-display'],
+      '#required' => TRUE,
+      '#ajax' => [
+        'callback' => '::updatePluginConfigurationForm',
+        'wrapper' => 'data-entity-embed-display-settings-wrapper',
+        'effect' => 'fade',
+      ],
+      // Hide the selection if only one option is available.
+      '#access' => count($display_plugin_options) > 1,
+    ];
+    $form['attributes']['data-entity-embed-display-settings'] = [
+      '#type' => 'container',
+      '#prefix' => '<div id="data-entity-embed-display-settings-wrapper">',
+      '#suffix' => '</div>',
+    ];
+    $form['attributes']['data-embed-button'] = [
+      '#type' => 'value',
+      '#value' => $embed_button->id(),
+    ];
+    $plugin_id = !empty($values['attributes']['data-entity-embed-display']) ? $values['attributes']['data-entity-embed-display'] : $entity_element['data-entity-embed-display'];
+    if (!empty($plugin_id)) {
+      if (empty($entity_element['data-entity-embed-display-settings'])) {
+        $entity_element['data-entity-embed-display-settings'] = [];
+      }
+      elseif (is_string($entity_element['data-entity-embed-display-settings'])) {
+        $entity_element['data-entity-embed-display-settings'] = Json::decode($entity_element['data-entity-embed-display-settings']) ?: [];
+      }
+      $display = $this->entityEmbedDisplayManager->createInstance($plugin_id, $entity_element['data-entity-embed-display-settings']);
+      $display->setContextValue('entity', $entity);
+      $display->setAttributes($entity_element);
+      $form['attributes']['data-entity-embed-display-settings'] += $display->buildConfigurationForm($form, $form_state);
+    }
+
+    // When Drupal core's filter_align is being used, the text editor may
+    // offer the ability to change the alignment.
+    if ($editor->getFilterFormat()->filters('filter_align')->status) {
+      $form['attributes']['data-align'] = [
+        '#title' => $this->t('Align'),
+        '#type' => 'radios',
+        '#options' => [
+          '' => $this->t('None'),
+          'left' => $this->t('Left'),
+          'center' => $this->t('Center'),
+          'right' => $this->t('Right'),
+        ],
+        '#default_value' => isset($entity_element['data-align']) ? $entity_element['data-align'] : '',
+        '#wrapper_attributes' => ['class' => ['container-inline']],
+        '#attributes' => ['class' => ['container-inline']],
+      ];
+    }
+
+    // When Drupal core's filter_caption is being used, the text editor may
+    // offer the ability to add a caption.
+    if ($editor->getFilterFormat()->filters('filter_caption')->status) {
+      $form['attributes']['data-caption'] = [
+        '#title' => $this->t('Caption'),
+        '#type' => 'textarea',
+        '#rows' => 3,
+        '#default_value' => isset($entity_element['data-caption']) ? Html::decodeEntities($entity_element['data-caption']) : '',
+        '#element_validate' => ['::escapeValue'],
+      ];
+    }
+
+    $form['actions'] = [
+      '#type' => 'actions',
+    ];
+    $form['actions']['back'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Back'),
+      // No regular submit-handler. This form only works via JavaScript.
+      '#submit' => [],
+      '#ajax' => [
+        'callback' => !empty($this->entityBrowserSettings['display_review']) ? '::submitAndShowReview' : '::submitAndShowSelect',
+        'event' => 'click',
+      ],
+    ];
+    $form['actions']['save_modal'] = [
+      '#type' => 'submit',
+      '#value' => $this->t('Embed'),
+      '#button_type' => 'primary',
+      // No regular submit-handler. This form only works via JavaScript.
+      '#submit' => [],
+      '#ajax' => [
+        'callback' => '::submitEmbedStep',
+        'event' => 'click',
+      ],
+    ];
+
+    return $form;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function validateForm(array &$form, FormStateInterface $form_state) {
+    parent::validateForm($form, $form_state);
+
+    if ($form_state->get('step') == 'select') {
+      $this->validateSelectStep($form, $form_state);
+    }
+    elseif ($form_state->get('step') == 'embed') {
+      $this->validateEmbedStep($form, $form_state);
+    }
+  }
+
+  /**
+   * Form validation handler for the entity selection step.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The current state of the form.
+   */
+  public function validateSelectStep(array $form, FormStateInterface $form_state) {
+    if ($form_state->hasValue(['entity_browser', 'entities'])) {
+      if (count($form_state->getValue(['entity_browser', 'entities'])) > 0) {
+        $id = $form_state->getValue(['entity_browser', 'entities', 0])->id();
+      }
+      $element = $form['entity_browser'];
+    }
+    else {
+      $id = trim($form_state->getValue(['entity_id']));
+      $element = $form['entity_id'];
+    }
+
+    $entity_type = $form_state->getValue(['attributes', 'data-entity-type']);
+
+    if (!isset($id)) {
+      $form_state->setError($element, $this->t('No entity selected.'));
+      return;
+    }
+    if ($entity = $this->entityTypeManager->getStorage($entity_type)->load($id)) {
+      if (!$entity->access('view')) {
+        $form_state->setError($element, $this->t('Unable to access @type entity @id.', ['@type' => $entity_type, '@id' => $id]));
+      }
+      else {
+        if ($uuid = $entity->uuid()) {
+          $form_state->setValueForElement($form['attributes']['data-entity-uuid'], $uuid);
+        }
+        else {
+          $form_state->setError($element, $this->t('Cannot embed @type entity @id because it does not have a UUID.', ['@type' => $entity_type, '@id' => $id]));
+        }
+
+        // Ensure that at least one Entity Embed Display plugin is present
+        // before proceeding to the next step. Raise an error otherwise.
+        $embed_button = $form_state->get('embed_button');
+        $display_plugin_options = $this->getDisplayPluginOptions($embed_button, $entity);
+        // If no plugin is available after taking the intersection, raise error.
+        // Also log an exception.
+        if (empty($display_plugin_options)) {
+          $form_state->setError($element, $this->t('No display options available for the selected %entity-type. Please select another %entity_type.', ['%entity_type' => $entity->getEntityType()->getLabel()]));
+          $this->logger('entity_embed')->warning('No display options available for "@type:" entity "@id" while embedding using button "@button". Please ensure that at least one Entity Embed Display plugin is allowed for this embed button which is available for this entity.', [
+            '@type' => $entity_type,
+            '@id' => $entity->id(),
+            '@button' => $embed_button->id(),
+          ]);
+        }
+      }
+    }
+    else {
+      $form_state->setError($element, $this->t('Unable to load @type entity @id.', ['@type' => $entity_type, '@id' => $id]));
+    }
+  }
+
+  /**
+   * Form validation handler for the entity embedding step.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The current state of the form.
+   */
+  public function validateEmbedStep(array $form, FormStateInterface $form_state) {
+    // Validate configuration forms for the Entity Embed Display plugin used.
+    $entity_element = $form_state->getValue('attributes');
+    $entity = $form_state->get('entity');
+    $plugin_id = $entity_element['data-entity-embed-display'];
+    $plugin_settings = !empty($entity_element['data-entity-embed-display-settings']) ? $entity_element['data-entity-embed-display-settings'] : [];
+    $display = $this->entityEmbedDisplayManager->createInstance($plugin_id, $plugin_settings);
+    $display->setContextValue('entity', $entity);
+    $display->setAttributes($entity_element);
+    $display->validateConfigurationForm($form, $form_state);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function submitForm(array &$form, FormStateInterface $form_state) {}
+
+  /**
+   * Form submission handler to update the plugin configuration form.
+   *
+   * @param array $form
+   *   The form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state.
+   */
+  public function updatePluginConfigurationForm(array &$form, FormStateInterface $form_state) {
+    return $form['attributes']['data-entity-embed-display-settings'];
+  }
+
+  /**
+   * Form submission handler to to another step of the form.
+   *
+   * @param array $form
+   *   The form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state.
+   * @param string $step
+   *   The next step name, such as 'select', 'review' or 'embed'.
+   *
+   * @return \Drupal\Core\Ajax\AjaxResponse
+   *   The ajax response.
+   */
+  public function submitStep(array &$form, FormStateInterface $form_state, $step) {
+    $response = new AjaxResponse();
+
+    $form_state->set('step', $step);
+    $form_state->setRebuild(TRUE);
+    $rebuild_form = $this->formBuilder->rebuildForm('entity_embed_dialog', $form_state, $form);
+    unset($rebuild_form['#prefix'], $rebuild_form['#suffix']);
+    $response->addCommand(new HtmlCommand('#entity-embed-dialog-form', $rebuild_form));
+    $response->addCommand(new SetDialogTitleCommand('', $rebuild_form['#title']));
+
+    return $response;
+  }
+
+  /**
+   * Form submission handler for the entity selection step.
+   *
+   * On success will send the user to the next step of the form to select the
+   * embed display settings. On form errors, this will rebuild the form and
+   * display the error messages.
+   *
+   * @param array $form
+   *   The form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state.
+   *
+   * @return \Drupal\Core\Ajax\AjaxResponse
+   *   The ajax response.
+   */
+  public function submitSelectStep(array &$form, FormStateInterface $form_state) {
+    $response = new AjaxResponse();
+
+    // Display errors in form, if any.
+    if ($form_state->hasAnyErrors()) {
+      unset($form['#prefix'], $form['#suffix']);
+      $form['status_messages'] = [
+        '#type' => 'status_messages',
+        '#weight' => -10,
+      ];
+      $response->addCommand(new HtmlCommand('#entity-embed-dialog-form', $form));
+    }
+    else {
+      $form_state->set('step', !empty($this->entityBrowserSettings['display_review']) ? 'review' : 'embed');
+      $form_state->setRebuild(TRUE);
+      $rebuild_form = $this->formBuilder->rebuildForm('entity_embed_dialog', $form_state, $form);
+      unset($rebuild_form['#prefix'], $rebuild_form['#suffix']);
+      $response->addCommand(new HtmlCommand('#entity-embed-dialog-form', $rebuild_form));
+      $response->addCommand(new SetDialogTitleCommand('', $rebuild_form['#title']));
+    }
+
+    return $response;
+  }
+
+  /**
+   * Submit and show select step after submit.
+   *
+   * @param array $form
+   *   The form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state.
+   *
+   * @return \Drupal\Core\Ajax\AjaxResponse
+   *   The ajax response.
+   */
+  public function submitAndShowSelect(array &$form, FormStateInterface $form_state) {
+    return $this->submitStep($form, $form_state, 'select');
+  }
+
+  /**
+   * Submit and show review step after submit.
+   *
+   * @param array $form
+   *   The form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state.
+   *
+   * @return \Drupal\Core\Ajax\AjaxResponse
+   *   The ajax response.
+   */
+  public function submitAndShowReview(array &$form, FormStateInterface $form_state) {
+    return $this->submitStep($form, $form_state, 'review');
+  }
+
+  /**
+   * Submit and show embed step after submit.
+   *
+   * @param array $form
+   *   The form array.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state.
+   *
+   * @return \Drupal\Core\Ajax\AjaxResponse
+   *   The ajax response.
+   */
+  public function submitAndShowEmbed(array $form, FormStateInterface $form_state) {
+    return $this->submitStep($form, $form_state, 'embed');
+  }
+
+  /**
+   * Form submission handler for the entity embedding step.
+   *
+   * On success this will submit the command to save the embedded entity with
+   * the configured display settings to the WYSIWYG element, and then close the
+   * modal dialog. On form errors, this will rebuild the form and display the
+   * error messages.
+   *
+   * @param array $form
+   *   An associative array containing the structure of the form.
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state object.
+   *
+   * @return \Drupal\Core\Ajax\AjaxResponse
+   *   The ajax response.
+   */
+  public function submitEmbedStep(array &$form, FormStateInterface $form_state) {
+    $response = new AjaxResponse();
+
+    // Submit configuration form the selected Entity Embed Display plugin.
+    $entity_element = $form_state->getValue('attributes');
+    $entity = $this->loadEntityByAttributes($entity_element);
+    $plugin_id = $entity_element['data-entity-embed-display'];
+    $plugin_settings = !empty($entity_element['data-entity-embed-display-settings']) ? $entity_element['data-entity-embed-display-settings'] : [];
+    $display = $this->entityEmbedDisplayManager->createInstance($plugin_id, $plugin_settings);
+    $display->setContextValue('entity', $entity);
+    $display->setAttributes($entity_element);
+    $display->submitConfigurationForm($form, $form_state);
+
+    $values = $form_state->getValues();
+    // Display errors in form, if any.
+    if ($form_state->hasAnyErrors()) {
+      unset($form['#prefix'], $form['#suffix']);
+      $form['status_messages'] = [
+        '#type' => 'status_messages',
+        '#weight' => -10,
+      ];
+      $response->addCommand(new HtmlCommand('#entity-embed-dialog-form', $form));
+    }
+    else {
+      // Serialize entity embed settings to JSON string.
+      if (!empty($values['attributes']['data-entity-embed-display-settings'])) {
+        $values['attributes']['data-entity-embed-display-settings'] = Json::encode($values['attributes']['data-entity-embed-display-settings']);
+      }
+
+      // Filter out empty attributes.
+      $values['attributes'] = array_filter($values['attributes'], function ($value) {
+        return (bool) mb_strlen((string) $value);
+      });
+
+      // Allow other modules to alter the values before getting submitted to the
+      // WYSIWYG.
+      $this->moduleHandler->alter('entity_embed_values', $values, $entity, $display);
+
+      $response->addCommand(new EditorDialogSave($values));
+      $response->addCommand(new CloseModalDialogCommand());
+    }
+
+    return $response;
+  }
+
+  /**
+   * Form element validation handler; Escapes the value an element.
+   *
+   * This should be used for any element in the embed form which may contain
+   * HTML that should be serialized as an attribute element on the embed.
+   */
+  public static function escapeValue($element, FormStateInterface $form_state) {
+    if ($value = trim($element['#value'])) {
+      $form_state->setValueForElement($element, Html::escape($value));
+    }
+  }
+
+  /**
+   * Returns the allowed display plugins given an embed button and an entity.
+   *
+   * @param \Drupal\embed\EmbedButtonInterface $embed_button
+   *   The embed button.
+   * @param \Drupal\Core\Entity\EntityInterface $entity
+   *   The entity.
+   *
+   * @return array
+   *   List of allowed Entity Embed Display plugins.
+   */
+  public function getDisplayPluginOptions(EmbedButtonInterface $embed_button, EntityInterface $entity) {
+    $plugins = $this->entityEmbedDisplayManager->getDefinitionOptionsForContext([
+      'entity' => $entity,
+      'entity_type' => $entity->getEntityTypeId(),
+      'embed_button' => $embed_button,
+    ]);
+
+    return $plugins;
+  }
+
+  /**
+   * Registers JS callbacks.
+   *
+   * Callbacks are responsible for getting entities from entity browser and
+   * updating form values accordingly.
+   */
+  public function registerJSCallback(RegisterJSCallbacks $event) {
+    if ($event->getBrowserID() == $this->entityBrowser->id()) {
+      $event->registerCallback('Drupal.entityEmbedDialog.selectionCompleted');
+    }
+  }
+
+  /**
+   * Load the current entity browser and its settings from the form state.
+   *
+   * @param \Drupal\Core\Form\FormStateInterface $form_state
+   *   The form state object.
+   */
+  protected function loadEntityBrowser(FormStateInterface $form_state) {
+    $this->entityBrowser = NULL;
+    $this->entityBrowserSettings = [];
+
+    /** @var \Drupal\embed\EmbedButtonInterface $embed_button */
+    $embed_button = $form_state->get('embed_button');
+
+    if ($embed_button && $entity_browser_id = $embed_button->getTypePlugin()->getConfigurationValue('entity_browser')) {
+      $this->entityBrowser = $this->entityTypeManager->getStorage('entity_browser')->load($entity_browser_id);
+      $this->entityBrowserSettings = $embed_button->getTypePlugin()->getConfigurationValue('entity_browser_settings');
+    }
+  }
+
+}
diff -ruN a/src/Plugin/CKEditor4To5Upgrade/EntityEmbed.php b/src/Plugin/CKEditor4To5Upgrade/EntityEmbed.php
--- a/src/Plugin/CKEditor4To5Upgrade/EntityEmbed.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/CKEditor4To5Upgrade/EntityEmbed.php	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,62 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\CKEditor4To5Upgrade;
+
+use Drupal\ckeditor5\HTMLRestrictions;
+use Drupal\ckeditor5\Plugin\CKEditor4To5UpgradePluginInterface;
+use Drupal\Core\Plugin\PluginBase;
+use Drupal\filter\FilterFormatInterface;
+
+/**
+ * Provides the CKEditor 4 to 5 upgrade path for entity embed buttons.
+ *
+ * @CKEditor4To5Upgrade(
+ *   id = "entity_embed",
+ *   cke4_buttons = {
+ *   },
+ *   cke4_plugin_settings = {
+ *   },
+ *   cke5_plugin_elements_subset_configuration = {
+ *   }
+ * )
+ *
+ * @internal
+ *   Plugin classes are internal.
+ */
+class EntityEmbed extends PluginBase implements CKEditor4To5UpgradePluginInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function mapCKEditor4ToolbarButtonToCKEditor5ToolbarItem(string $cke4_button, HTMLRestrictions $text_format_html_restrictions): ?array {
+    $buttons = [];
+
+    $embed_buttons = \Drupal::entityTypeManager()
+      ->getStorage('embed_button')
+      ->loadMultiple();
+    foreach ($embed_buttons as $embed_button) {
+      $buttons[] = $embed_button->id();
+    }
+    foreach ($buttons as $button) {
+      if ($cke4_button == $button) {
+        return [$button];
+      }
+    }
+
+    throw new \OutOfBoundsException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function mapCKEditor4SettingsToCKEditor5Configuration(string $cke4_plugin_id, array $cke4_plugin_settings): ?array {
+    throw new \OutOfBoundsException();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function computeCKEditor5PluginSubsetConfiguration(string $cke5_plugin_id, FilterFormatInterface $text_format): ?array {
+    throw new \OutOfBoundsException();
+  }
+}
diff -ruN a/src/Plugin/CKEditor5Plugin/DrupalEntity.php b/src/Plugin/CKEditor5Plugin/DrupalEntity.php
--- a/src/Plugin/CKEditor5Plugin/DrupalEntity.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/CKEditor5Plugin/DrupalEntity.php	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,129 @@
+<?php
+
+declare(strict_types = 1);
+
+namespace Drupal\entity_embed\Plugin\CKEditor5Plugin;
+
+use Drupal\ckeditor5\Plugin\CKEditor5PluginDefault;
+use Drupal\ckeditor5\Plugin\CKEditor5PluginDefinition;
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Access\CsrfTokenGenerator;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Drupal\editor\EditorInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * @CKEditor5Plugin(
+ *   id = "entity_embed_drupalentity",
+ *   ckeditor5 = @CKEditor5AspectsOfCKEditor5Plugin(
+ *     plugins = {"drupalentity.EntityEmbed"},
+ *     config = {},
+ *   ),
+ *   drupal = @DrupalAspectsOfCKEditor5Plugin(
+ *     deriver = "Drupal\entity_embed\Plugin\CKEditor5Plugin\DrupalEntityDeriver",
+ *     library = "entity_embed/entity_embed",
+ *     admin_library = "entity_embed/admin.entity_embed",
+ *     elements = {
+ *       "<drupal-entity>",
+ *       "<drupal-entity alt data-align data-caption data-entity-embed-display data-entity-embed-display-settings data-entity-uuid>",
+ *     },
+ *     conditions = {
+ *       "filter" = "entity_embed",
+ *     },
+ *   )
+ * )
+ */
+class DrupalEntity extends CKEditor5PluginDefault implements ContainerFactoryPluginInterface {
+
+  /**
+   * The CSRF Token generator.
+   *
+   * @var \Drupal\Core\Access\CsrfTokenGenerator
+   */
+  protected $csrfTokenGenerator;
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * DrupalEntity constructor.
+   *
+   * @param array $configuration
+   *   A configuration array containing information about the plugin instance.
+   * @param string $plugin_id
+   *   The plugin_id for the plugin instance.
+   * @param \Drupal\ckeditor5\Plugin\CKEditor5PluginDefinition $plugin_definition
+   *   The plugin implementation definition.
+   * @param \Drupal\Core\Access\CsrfTokenGenerator $csrf_token_generator
+   *   The CSRF Token generator service.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The Entity Type Manager service.
+   */
+  public function __construct(
+    array $configuration,
+    string $plugin_id,
+    CKEditor5PluginDefinition $plugin_definition,
+    CsrfTokenGenerator $csrf_token_generator,
+    EntityTypeManagerInterface $entity_type_manager
+  ) {
+    parent::__construct($configuration, $plugin_id, $plugin_definition);
+    $this->csrfTokenGenerator = $csrf_token_generator;
+    $this->entityTypeManager = $entity_type_manager;
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $configuration,
+      $plugin_id,
+      $plugin_definition,
+      $container->get('csrf_token'),
+      $container->get('entity_type.manager')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDynamicPluginConfig(array $static_plugin_config, EditorInterface $editor): array {
+    // Register embed buttons as individual buttons on admin pages.
+    $dynamic_plugin_config = $static_plugin_config;
+    $embed_buttons = $this
+      ->entityTypeManager
+      ->getStorage('embed_button')
+      ->loadMultiple();
+    $buttons = [];
+    /** @var \Drupal\embed\EmbedButtonInterface $embed_button */
+    foreach ($embed_buttons as $embed_button) {
+      $id = $embed_button->id();
+      $label = Html::escape($embed_button->label());
+      $buttons[$id] = [
+        'id' => $id,
+        'name' => $label,
+        'label' => $label,
+        'icon' => $embed_button->getIconUrl(),
+      ];
+    }
+    // Add configured embed buttons and pass it to the UI.
+    $dynamic_plugin_config['entityEmbed'] = [
+      'buttons' => $buttons,
+      'format' => $editor->getFilterFormat()->id(),
+      'dialogSettings' => [
+        'dialogClass' => 'entity-select-dialog',
+        'height' => 'auto',
+        'width' => 'auto',
+      ],
+      'previewCsrfToken' => $this->csrfTokenGenerator->get('X-Drupal-EmbedPreview-CSRF-Token'),
+    ];
+
+    return $dynamic_plugin_config;
+  }
+
+}
diff -ruN a/src/Plugin/CKEditor5Plugin/DrupalEntityDeriver.php b/src/Plugin/CKEditor5Plugin/DrupalEntityDeriver.php
--- a/src/Plugin/CKEditor5Plugin/DrupalEntityDeriver.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/CKEditor5Plugin/DrupalEntityDeriver.php	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,74 @@
+<?php
+
+declare(strict_types = 1);
+
+namespace Drupal\entity_embed\Plugin\CKEditor5Plugin;
+
+use Drupal\ckeditor5\Plugin\CKEditor5PluginDefinition;
+use Drupal\Component\Plugin\Derivative\DeriverBase;
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Plugin\Discovery\ContainerDeriverInterface;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+class DrupalEntityDeriver extends DeriverBase implements ContainerDeriverInterface {
+
+  use StringTranslationTrait;
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $embedButtonStorage;
+
+  /**
+   * Constructs a new DrupalEntityDeriver object.
+   *
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager.
+   *
+   * @throws \Drupal\Component\Plugin\Exception\InvalidPluginDefinitionException
+   * @throws \Drupal\Component\Plugin\Exception\PluginNotFoundException
+   */
+  public function __construct(EntityTypeManagerInterface $entity_type_manager) {
+    $this->embedButtonStorage = $entity_type_manager->getStorage('embed_button');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, $base_plugin_id) {
+    return new static(
+      $container->get('entity_type.manager')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDerivativeDefinitions($base_plugin_definition) {
+    assert($base_plugin_definition instanceof CKEditor5PluginDefinition);
+    /** @var \Drupal\embed\EmbedButtonInterface $embed_button */
+    foreach ($this->embedButtonStorage->loadMultiple() as $embed_button) {
+      $embed_button_id = $embed_button->id();
+      $embed_button_label = Html::escape($embed_button->label());
+      $plugin_id = "entity_embed_{$embed_button_id}";
+      $definition = $base_plugin_definition->toArray();
+      $definition['id'] .= $embed_button_id;
+      $definition['drupal']['label'] = $this->t('Entity Embed - @label', ['@label' => $embed_button_label])->render();
+      $definition['drupal']['toolbar_items'] = [
+        $embed_button_id => [
+          'label' => $embed_button_label,
+        ],
+      ];
+      $definition['drupal']['elements'][] = '<drupal-entity data-embed-button="' . $embed_button_id . '">';
+      $definition['drupal']['elements'][] = '<drupal-entity data-entity-type="' . $embed_button->getTypeSetting('entity_type') . '">';
+      $this->derivatives[$plugin_id] = new CKEditor5PluginDefinition($definition);
+    }
+
+    return $this->derivatives;
+  }
+
+}
diff -ruN a/src/Plugin/CKEditorPlugin/DrupalEntity.php b/src/Plugin/CKEditorPlugin/DrupalEntity.php
--- a/src/Plugin/CKEditorPlugin/DrupalEntity.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/CKEditorPlugin/DrupalEntity.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,59 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\CKEditorPlugin;
+
+use Drupal\ckeditor\CKEditorPluginCssInterface;
+use Drupal\editor\Entity\Editor;
+use Drupal\embed\EmbedButtonInterface;
+use Drupal\embed\EmbedCKEditorPluginBase;
+
+/**
+ * Defines the "drupalentity" plugin.
+ *
+ * @CKEditorPlugin(
+ *   id = "drupalentity",
+ *   label = @Translation("Entity"),
+ *   embed_type_id = "entity"
+ * )
+ */
+class DrupalEntity extends EmbedCKEditorPluginBase implements CKEditorPluginCssInterface {
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function getButton(EmbedButtonInterface $embed_button) {
+    $button = parent::getButton($embed_button);
+    $button['entity_type'] = $embed_button->getTypeSetting('entity_type');
+    return $button;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFile() {
+    return $this->getModulePath('entity_embed') . '/js/plugins/drupalentity/plugin.js';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getConfig(Editor $editor) {
+    return [
+      'DrupalEntity_dialogTitleAdd' => t('Insert entity'),
+      'DrupalEntity_dialogTitleEdit' => t('Edit entity'),
+      'DrupalEntity_buttons' => $this->getButtons(),
+      'DrupalEntity_previewCsrfToken' => \Drupal::csrfToken()->get('X-Drupal-EmbedPreview-CSRF-Token'),
+    ];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getCssFiles(Editor $editor) {
+    return [
+      $this->getModulePath('system') . '/css/components/hidden.module.css',
+      $this->getModulePath('entity_embed') . '/css/entity_embed.editor.css',
+    ];
+  }
+
+}
diff -ruN a/src/Plugin/Derivative/FieldFormatterDeriver.php b/src/Plugin/Derivative/FieldFormatterDeriver.php
--- a/src/Plugin/Derivative/FieldFormatterDeriver.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/Derivative/FieldFormatterDeriver.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,88 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\Derivative;
+
+use Drupal\Component\Plugin\Derivative\DeriverBase;
+use Drupal\Core\Config\ConfigFactoryInterface;
+use Drupal\Core\Plugin\Discovery\ContainerDeriverInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Drupal\Core\Field\FormatterPluginManager;
+
+/**
+ * Provides Entity Embed Display plugin definitions for field formatters.
+ *
+ * @see \Drupal\entity_embed\FieldFormatterEntityEmbedDisplayBase
+ */
+class FieldFormatterDeriver extends DeriverBase implements ContainerDeriverInterface {
+
+  /**
+   * The manager for formatter plugins.
+   *
+   * @var \Drupal\Core\Field\FormatterPluginManager
+   */
+  protected $formatterManager;
+
+  /**
+   * The config factory service.
+   *
+   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   */
+  protected $configFactory;
+
+  /**
+   * Constructs new FieldFormatterEntityEmbedDisplayBase.
+   *
+   * @param \Drupal\Core\Field\FormatterPluginManager $formatter_manager
+   *   The field formatter plugin manager.
+   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
+   *   A config factory for retrieving required config objects.
+   */
+  public function __construct(FormatterPluginManager $formatter_manager, ConfigFactoryInterface $config_factory) {
+    $this->formatterManager = $formatter_manager;
+    $this->configFactory = $config_factory;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, $base_plugin_id) {
+    return new static(
+      $container->get('plugin.manager.field.formatter'),
+      $container->get('config.factory')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   *
+   * @throws \LogicException
+   *   Throws an exception if field type is not defined in the annotation of the
+   *   Entity Embed Display plugin.
+   */
+  public function getDerivativeDefinitions($base_plugin_definition) {
+    // The field type must be defined in the annotation of the Entity Embed
+    // Display plugin.
+    if (!isset($base_plugin_definition['field_type'])) {
+      throw new \LogicException("Undefined field_type definition in plugin {$base_plugin_definition['id']}.");
+    }
+
+    $no_media_image_decorator = [
+      'entity_reference_entity_id',
+      'entity_reference_label',
+    ];
+
+    foreach ($this->formatterManager->getOptions($base_plugin_definition['field_type']) as $formatter => $label) {
+      $this->derivatives[$formatter] = $base_plugin_definition;
+      $this->derivatives[$formatter]['label'] = $label;
+
+      // The base entity embed display plugin annotation has opted into
+      // `supports_image_alt_and_title`. For some derivatives we know that they
+      // do not support this, so opt them back out.
+      if (in_array($formatter, $no_media_image_decorator, TRUE)) {
+        $this->derivatives[$formatter]['supports_image_alt_and_title'] = FALSE;
+      }
+    }
+    return $this->derivatives;
+  }
+
+}
diff -ruN a/src/Plugin/Derivative/ViewModeDeriver.php b/src/Plugin/Derivative/ViewModeDeriver.php
--- a/src/Plugin/Derivative/ViewModeDeriver.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/Derivative/ViewModeDeriver.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,76 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\Derivative;
+
+use Drupal\Component\Plugin\Derivative\DeriverBase;
+use Drupal\Core\Config\ConfigFactoryInterface;
+use Drupal\Core\Entity\EntityDisplayRepositoryInterface;
+use Drupal\Core\Plugin\Discovery\ContainerDeriverInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Provides Entity Embed Display plugin definitions for view modes.
+ *
+ * @see \Drupal\entity_embed\FieldFormatterEntityEmbedDisplayBase
+ */
+class ViewModeDeriver extends DeriverBase implements ContainerDeriverInterface {
+
+  /**
+   * The entity display repository.
+   *
+   * @var \Drupal\Core\Entity\EntityDisplayRepositoryInterface
+   */
+  protected $entityDisplayRepository;
+
+  /**
+   * The config factory service.
+   *
+   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   */
+  protected $configFactory;
+
+  /**
+   * Constructs a ViewModeDeriver object.
+   *
+   * @param \Drupal\Core\Entity\EntityDisplayRepositoryInterface $entity_display_repository
+   *   The entity display repository.
+   * @param \Drupal\Core\Config\ConfigFactoryInterface $config_factory
+   *   A config factory for retrieving required config objects.
+   */
+  public function __construct(EntityDisplayRepositoryInterface $entity_display_repository, ConfigFactoryInterface $config_factory) {
+    $this->entityDisplayRepository = $entity_display_repository;
+    $this->configFactory = $config_factory;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, $base_plugin_id) {
+    return new static(
+      $container->get('entity_display.repository'),
+      $container->get('config.factory')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDerivativeDefinitions($base_plugin_definition) {
+    $no_ui = $this->configFactory->get('entity_embed.settings')->get('rendered_entity_mode');
+    foreach ($this->entityDisplayRepository->getAllViewModes() as $view_modes) {
+      foreach ($view_modes as $view_mode => $definition) {
+        $this->derivatives[$definition['id']] = [
+          'label' => $definition['label'],
+          'view_mode' => $view_mode,
+          'entity_types' => [$definition['targetEntityType']],
+          'no_ui' => $no_ui,
+          // Check if the plugin should run through MediaImageDecorator. A more
+          // fine-grained access check happens there.
+          'supports_image_alt_and_title' => ($definition['targetEntityType'] === 'media'),
+        ] + $base_plugin_definition;
+      }
+    }
+    return $this->derivatives;
+  }
+
+}
diff -ruN a/src/Plugin/EmbedType/Entity.php b/src/Plugin/EmbedType/Entity.php
--- a/src/Plugin/EmbedType/Entity.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/EmbedType/Entity.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,314 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\EmbedType;
+
+use Drupal\Core\Entity\EntityTypeBundleInfoInterface;
+use Drupal\Core\Entity\EntityTypeInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Entity\EntityTypeRepositoryInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Drupal\Core\Plugin\PluginDependencyTrait;
+use Drupal\embed\EmbedType\EmbedTypeBase;
+use Drupal\entity_browser\EntityBrowserInterface;
+use Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Entity embed type.
+ *
+ * @EmbedType(
+ *   id = "entity",
+ *   label = @Translation("Entity")
+ * )
+ */
+class Entity extends EmbedTypeBase implements ContainerFactoryPluginInterface {
+  use PluginDependencyTrait;
+
+  /**
+   * The entity type manager service.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The entity type repository service.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeRepositoryInterface
+   */
+  protected $entityTypeRepository;
+
+  /**
+   * The entity type bundle info service.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeBundleInfoInterface
+   */
+  protected $entityTypeBundleInfo;
+
+  /**
+   * The Entity Embed Display plugin manager.
+   *
+   * @var \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager
+   */
+  protected $displayPluginManager;
+
+  /**
+   * {@inheritdoc}
+   *
+   * @param array $configuration
+   *   A configuration array containing information about the plugin instance.
+   * @param string $plugin_id
+   *   The plugin_id for the plugin instance.
+   * @param mixed $plugin_definition
+   *   The plugin implementation definition.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager service.
+   * @param \Drupal\Core\Entity\EntityTypeRepositoryInterface $entity_type_repository
+   *   The entity type repository service.
+   * @param \Drupal\Core\Entity\EntityTypeBundleInfoInterface $bundle_info
+   *   The entity type bundle info service.
+   * @param \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayManager $display_plugin_manager
+   *   The plugin manager.
+   */
+  public function __construct(array $configuration, $plugin_id, $plugin_definition, EntityTypeManagerInterface $entity_type_manager, EntityTypeRepositoryInterface $entity_type_repository, EntityTypeBundleInfoInterface $bundle_info, EntityEmbedDisplayManager $display_plugin_manager) {
+    parent::__construct($configuration, $plugin_id, $plugin_definition);
+    $this->entityTypeManager = $entity_type_manager;
+    $this->entityTypeRepository = $entity_type_repository;
+    $this->entityTypeBundleInfo = $bundle_info;
+    $this->displayPluginManager = $display_plugin_manager;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $configuration,
+      $plugin_id,
+      $plugin_definition,
+      $container->get('entity_type.manager'),
+      $container->get('entity_type.repository'),
+      $container->get('entity_type.bundle.info'),
+      $container->get('plugin.manager.entity_embed.display')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function defaultConfiguration() {
+    return [
+      'entity_type' => 'node',
+      'bundles' => [],
+      'display_plugins' => [],
+      'entity_browser' => '',
+      'entity_browser_settings' => [
+        'display_review' => 0,
+      ],
+    ];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    $embed_button = $form_state->getTemporaryValue('embed_button');
+    $entity_type_id = $this->getConfigurationValue('entity_type');
+
+    $form['entity_type'] = [
+      '#type' => 'select',
+      '#title' => $this->t('Entity type'),
+      '#options' => $this->getEntityTypeOptions(),
+      '#default_value' => $entity_type_id,
+      '#description' => $this->t("The entity type this button will embed."),
+      '#required' => TRUE,
+      '#ajax' => [
+        'callback' => [$form_state->getFormObject(), 'updateTypeSettings'],
+        'effect' => 'fade',
+      ],
+      '#disabled' => !$embed_button->isNew(),
+    ];
+
+    if ($entity_type_id) {
+      $entity_type = $this->entityTypeManager->getDefinition($entity_type_id);
+      $form['bundles'] = [
+        '#type' => 'checkboxes',
+        '#title' => $entity_type->getBundleLabel() ?: $this->t('Bundles'),
+        '#options' => $this->getEntityBundleOptions($entity_type),
+        '#default_value' => $this->getConfigurationValue('bundles'),
+        '#description' => $this->t('If none are selected, all are allowed.'),
+      ];
+      $form['bundles']['#access'] = !empty($form['bundles']['#options']);
+
+      // Allow option to limit Entity Embed Display plugins.
+      $form['display_plugins'] = [
+        '#type' => 'checkboxes',
+        '#title' => $this->t('Allowed Entity Embed Display plugins'),
+        '#options' => $this->displayPluginManager->getDefinitionOptionsForEntityType($entity_type_id),
+        '#default_value' => $this->getConfigurationValue('display_plugins'),
+        '#description' => $this->t('If none are selected, all are allowed. Note that these are the plugins which are allowed for this entity type, all of these might not be available for the selected entity.'),
+      ];
+      $form['display_plugins']['#access'] = !empty($form['display_plugins']['#options']);
+
+      /** @var \Drupal\entity_browser\EntityBrowserInterface[] $browsers */
+      if ($this->entityTypeManager->hasDefinition('entity_browser') && ($browsers = $this->entityTypeManager->getStorage('entity_browser')->loadMultiple())) {
+        // Filter out unsupported displays & return array of ids and labels.
+        $browsers = array_map(
+          function ($item) {
+            /** @var \Drupal\entity_browser\EntityBrowserInterface $item */
+            return $item->label();
+          },
+          // Filter out both modal and standalone forms as they don't work.
+          array_filter($browsers, function (EntityBrowserInterface $browser) {
+            return !in_array($browser->getDisplay()->getPluginId(), ['modal', 'standalone'], TRUE);
+          })
+        );
+        $options = ['_none' => $this->t('None (autocomplete)')] + $browsers;
+        $form['entity_browser'] = [
+          '#type' => 'select',
+          '#title' => $this->t('Entity browser'),
+          '#description' => $this->t('Entity browser to be used to select entities to be embedded. Only compatible browsers will be available to be chosen.'),
+          '#options' => $options,
+          '#default_value' => $this->getConfigurationValue('entity_browser'),
+        ];
+        $form['entity_browser_settings'] = [
+          '#type' => 'details',
+          '#title' => $this->t('Entity browser settings'),
+          '#open' => TRUE,
+          '#states' => [
+            'invisible' => [
+              ':input[name="type_settings[entity_browser]"]' => ['value' => '_none'],
+            ],
+          ],
+        ];
+        $form['entity_browser_settings']['display_review'] = [
+          '#type' => 'checkbox',
+          '#title' => 'Display the entity after selection',
+          '#default_value' => $this->getConfigurationValue('entity_browser_settings')['display_review'],
+        ];
+      }
+      else {
+        $form['entity_browser'] = [
+          '#type' => 'value',
+          '#value' => '',
+        ];
+      }
+    }
+
+    return $form;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
+    // Filter down the bundles and allowed Entity Embed Display plugins.
+    $bundles = $form_state->getValue('bundles');
+    $form_state->setValue('bundles', array_keys(array_filter($bundles)));
+    $display_plugins = $form_state->getValue('display_plugins');
+    $form_state->setValue('display_plugins', array_keys(array_filter($display_plugins)));
+    $entity_browser = $form_state->getValue('entity_browser') == '_none' ? '' : $form_state->getValue('entity_browser');
+    $form_state->setValue('entity_browser', $entity_browser);
+    $form_state->setValue('entity_browser_settings', $form_state->getValue('entity_browser_settings', []));
+
+    parent::submitConfigurationForm($form, $form_state);
+  }
+
+  /**
+   * Builds a list of entity type options.
+   *
+   * Configuration entity types without a view builder are filtered out while
+   * all other entity types are kept.
+   *
+   * @return array
+   *   An array of entity type labels, keyed by entity type name.
+   */
+  protected function getEntityTypeOptions() {
+    $options = $this->entityTypeRepository->getEntityTypeLabels(TRUE);
+
+    foreach ($options as $group => $group_types) {
+      foreach (array_keys($group_types) as $entity_type_id) {
+        // Filter out entity types that do not have a view builder class.
+        if (!$this->entityTypeManager->getDefinition($entity_type_id)->hasViewBuilderClass()) {
+          unset($options[$group][$entity_type_id]);
+        }
+        // Filter out entity types that do not support UUIDs.
+        elseif (!$this->entityTypeManager->getDefinition($entity_type_id)->hasKey('uuid')) {
+          unset($options[$group][$entity_type_id]);
+        }
+        // Filter out entity types that will not have any Entity Embed Display
+        // plugins.
+        elseif (!$this->displayPluginManager->getDefinitionOptionsForEntityType($entity_type_id)) {
+          unset($options[$group][$entity_type_id]);
+        }
+      }
+    }
+
+    return $options;
+  }
+
+  /**
+   * Builds a list of entity type bundle options.
+   *
+   * Configuration entity types without a view builder are filtered out while
+   * all other entity types are kept.
+   *
+   * @return array
+   *   An array of bundle labels, keyed by bundle name.
+   */
+  protected function getEntityBundleOptions(EntityTypeInterface $entity_type) {
+    $bundle_options = [];
+    // If the entity has bundles, allow option to restrict to bundle(s).
+    if ($entity_type->hasKey('bundle')) {
+      foreach ($this->entityTypeBundleInfo->getBundleInfo($entity_type->id()) as $bundle_id => $bundle_info) {
+        $bundle_options[$bundle_id] = $bundle_info['label'];
+      }
+      natsort($bundle_options);
+    }
+    return $bundle_options;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getDefaultIconUrl() {
+    return file_create_url(drupal_get_path('module', 'entity_embed') . '/js/plugins/drupalentity/entity.png');
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function calculateDependencies() {
+    $this->addDependencies(parent::calculateDependencies());
+
+    $entity_type_id = $this->getConfigurationValue('entity_type');
+    $entity_type = $this->entityTypeManager->getDefinition($entity_type_id);
+    $this->addDependency('module', $entity_type->getProvider());
+
+    // Calculate bundle dependencies.
+    foreach ($this->getConfigurationValue('bundles') as $bundle) {
+      $bundle_dependency = $entity_type->getBundleConfigDependency($bundle);
+      $this->addDependency($bundle_dependency['type'], $bundle_dependency['name']);
+    }
+
+    // Calculate display Entity Embed Display dependencies.
+    foreach ($this->getConfigurationValue('display_plugins') as $display_plugin) {
+      $instance = $this->displayPluginManager->createInstance($display_plugin);
+      $this->calculatePluginDependencies($instance);
+    }
+
+    $entity_browser = $this->getConfigurationValue('entity_browser');
+    if ($entity_browser && $this->entityTypeManager->hasDefinition('entity_browser')) {
+      $browser = $this->entityTypeManager
+        ->getStorage('entity_browser')
+        ->load($entity_browser);
+      if ($browser) {
+        $this->addDependency($browser->getConfigDependencyKey(), $browser->getConfigDependencyName());
+      }
+    }
+
+    return $this->dependencies;
+  }
+
+}
diff -ruN a/src/Plugin/Filter/EntityEmbedFilter.php b/src/Plugin/Filter/EntityEmbedFilter.php
--- a/src/Plugin/Filter/EntityEmbedFilter.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/Filter/EntityEmbedFilter.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,241 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\Filter;
+
+use Drupal\Component\Utility\Html;
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Logger\LoggerChannelFactoryInterface;
+use Drupal\Core\Plugin\ContainerFactoryPluginInterface;
+use Drupal\Core\Render\BubbleableMetadata;
+use Drupal\Core\Render\RenderContext;
+use Drupal\Core\Render\RendererInterface;
+use Drupal\entity_embed\EntityEmbedBuilderInterface;
+use Drupal\entity_embed\Exception\EntityNotFoundException;
+use Drupal\filter\FilterProcessResult;
+use Drupal\filter\Plugin\FilterBase;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+use Drupal\embed\DomHelperTrait;
+
+/**
+ * Provides a filter to display embedded entities based on data attributes.
+ *
+ * @Filter(
+ *   id = "entity_embed",
+ *   title = @Translation("Display embedded entities"),
+ *   description = @Translation("Embeds entities using data attributes: data-entity-type, data-entity-uuid, and data-view-mode. Should usually run as the last filter, since it does not contain user input."),
+ *   type = Drupal\filter\Plugin\FilterInterface::TYPE_TRANSFORM_REVERSIBLE,
+ *   weight = 100,
+ * )
+ */
+class EntityEmbedFilter extends FilterBase implements ContainerFactoryPluginInterface {
+
+  use DomHelperTrait;
+
+  /**
+   * The number of times this formatter allows rendering the same entity.
+   *
+   * @var int
+   */
+  const RECURSIVE_RENDER_LIMIT = 20;
+
+  /**
+   * The renderer service.
+   *
+   * @var \Drupal\Core\Render\RendererInterface
+   */
+  protected $renderer;
+
+  /**
+   * The entity type manager.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The entity embed builder service.
+   *
+   * @var \Drupal\entity_embed\EntityEmbedBuilderInterface
+   */
+  protected $builder;
+
+  /**
+   * The logger factory.
+   *
+   * @var \Drupal\Core\Logger\LoggerChannelFactoryInterface
+   */
+  protected $loggerFactory;
+
+  /**
+   * An array of counters for the recursive rendering protection.
+   *
+   * Each counter takes into account all the relevant information about the
+   * field and the referenced entity that is being rendered.
+   *
+   * @var array
+   *
+   * @see \Drupal\Core\Field\Plugin\Field\FieldFormatter\EntityReferenceEntityFormatter::$recursiveRenderDepth
+   */
+  protected static $recursiveRenderDepth = [];
+
+  /**
+   * Constructs a EntityEmbedFilter object.
+   *
+   * @param array $configuration
+   *   A configuration array containing information about the plugin instance.
+   * @param string $plugin_id
+   *   The plugin ID for the plugin instance.
+   * @param mixed $plugin_definition
+   *   The plugin implementation definition.
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager.
+   * @param \Drupal\Core\Render\RendererInterface $renderer
+   *   The renderer.
+   * @param \Drupal\entity_embed\EntityEmbedBuilderInterface $builder
+   *   The entity embed builder service.
+   * @param \Drupal\Core\Logger\LoggerChannelFactoryInterface $logger_factory
+   *   The logger factory.
+   */
+  public function __construct(array $configuration, $plugin_id, $plugin_definition, EntityTypeManagerInterface $entity_type_manager, RendererInterface $renderer, EntityEmbedBuilderInterface $builder, LoggerChannelFactoryInterface $logger_factory) {
+    parent::__construct($configuration, $plugin_id, $plugin_definition);
+    $this->entityTypeManager = $entity_type_manager;
+    $this->renderer = $renderer;
+    $this->builder = $builder;
+    $this->loggerFactory = $logger_factory;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    return new static(
+      $configuration,
+      $plugin_id,
+      $plugin_definition,
+      $container->get('entity_type.manager'),
+      $container->get('renderer'),
+      $container->get('entity_embed.builder'),
+      $container->get('logger.factory')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function process($text, $langcode) {
+    $result = new FilterProcessResult($text);
+
+    if (strpos($text, 'data-entity-type') !== FALSE && (strpos($text, 'data-entity-embed-display') !== FALSE || strpos($text, 'data-view-mode') !== FALSE)) {
+      $dom = Html::load($text);
+      $xpath = new \DOMXPath($dom);
+
+      foreach ($xpath->query('//drupal-entity[@data-entity-type and (@data-entity-uuid or @data-entity-id) and (@data-entity-embed-display or @data-view-mode)]') as $node) {
+        /** @var \DOMElement $node */
+        $entity_type = $node->getAttribute('data-entity-type');
+        $entity = NULL;
+        $entity_output = '';
+
+        // data-entity-embed-settings is deprecated, make sure we convert it to
+        // data-entity-embed-display-settings.
+        if (($settings = $node->getAttribute('data-entity-embed-settings')) && !$node->hasAttribute('data-entity-embed-display-settings')) {
+          $node->setAttribute('data-entity-embed-display-settings', $settings);
+          $node->removeAttribute('data-entity-embed-settings');
+        }
+
+        $entity = NULL;
+        try {
+          // Load the entity either by UUID (preferred) or ID.
+          $id = NULL;
+          if ($id = $node->getAttribute('data-entity-uuid')) {
+            $entity = $this->entityTypeManager->getStorage($entity_type)
+              ->loadByProperties(['uuid' => $id]);
+            $entity = current($entity);
+          }
+          else {
+            $id = $node->getAttribute('data-entity-id');
+            $entity = $this->entityTypeManager->getStorage($entity_type)->load($id);
+          }
+          if (!$entity instanceof EntityInterface) {
+            $missing_text = $this->t('Missing @type.', ['@type' => $this->entityTypeManager->getDefinition($entity_type)->getSingularLabel()]);
+            $entity_output = '<img src="' . file_url_transform_relative(file_create_url('core/modules/media/images/icons/no-thumbnail.png')) . '" width="180" height="180" alt="' . $missing_text . '" title="' . $missing_text . '"/>';
+            throw new EntityNotFoundException(sprintf('Unable to load embedded %s entity %s.', $entity_type, $id));
+          }
+        }
+        catch (EntityNotFoundException $e) {
+          watchdog_exception('entity_embed', $e);
+        }
+
+        if ($entity instanceof EntityInterface) {
+          // If a UUID was not used, but is available, add it to the HTML.
+          if (!$node->getAttribute('data-entity-uuid') && $uuid = $entity->uuid()) {
+            $node->setAttribute('data-entity-uuid', $uuid);
+          }
+
+          $context = $this->getNodeAttributesAsArray($node);
+          $context += ['data-langcode' => $langcode];
+
+          // Due to render caching and delayed calls, filtering happens later
+          // in the rendering process through a '#pre_render' callback, so we
+          // need to generate a counter that takes into account all the
+          // relevant information about this field and the referenced entity
+          // that is being rendered.
+          // @see \Drupal\filter\Element\ProcessedText::preRenderText()
+          $recursive_render_id = $entity->uuid() . json_encode($context);
+          if (isset(static::$recursiveRenderDepth[$recursive_render_id])) {
+            static::$recursiveRenderDepth[$recursive_render_id]++;
+          }
+          else {
+            static::$recursiveRenderDepth[$recursive_render_id] = 1;
+          }
+
+          // Protect ourselves from recursive rendering.
+          if (static::$recursiveRenderDepth[$recursive_render_id] > static::RECURSIVE_RENDER_LIMIT) {
+            $this->loggerFactory->get('entity')->error('Recursive rendering detected when rendering embedded entity %entity_type: %entity_id. Aborting rendering.', [
+              '%entity_type' => $entity->getEntityTypeId(),
+              '%entity_id' => $entity->id(),
+            ]);
+            $entity_output = '';
+          }
+          else {
+            $build = $this->builder->buildEntityEmbed($entity, $context);
+            // We need to render the embedded entity:
+            // - without replacing placeholders, so that the placeholders are
+            //   only replaced at the last possible moment. Hence we cannot use
+            //   either renderPlain() or renderRoot(), so we must use render().
+            // - without bubbling beyond this filter, because filters must
+            //   ensure that the bubbleable metadata for the changes they make
+            //   when filtering text makes it onto the FilterProcessResult
+            //   object that they return ($result). To prevent that bubbling, we
+            //   must wrap the call to render() in a render context.
+            $entity_output = $this->renderer->executeInRenderContext(new RenderContext(), function () use (&$build) {
+              return $this->renderer->render($build);
+            });
+            $result = $result->merge(BubbleableMetadata::createFromRenderArray($build));
+          }
+        }
+
+        $this->replaceNodeContent($node, $entity_output);
+      }
+
+      $result->setProcessedText(Html::serialize($dom));
+    }
+
+    return $result;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function tips($long = FALSE) {
+    if ($long) {
+      return $this->t('
+        <p>You can embed entities. Additional properties can be added to the embed tag like data-caption and data-align if supported. Example:</p>
+        <code>&lt;drupal-entity data-entity-type="node" data-entity-uuid="07bf3a2e-1941-4a44-9b02-2d1d7a41ec0e" data-view-mode="teaser" /&gt;</code>');
+    }
+    else {
+      return $this->t('You can embed entities.');
+    }
+  }
+
+}
diff -ruN a/src/Plugin/entity_embed/EntityEmbedDisplay/EntityReferenceFieldFormatter.php b/src/Plugin/entity_embed/EntityEmbedDisplay/EntityReferenceFieldFormatter.php
--- a/src/Plugin/entity_embed/EntityEmbedDisplay/EntityReferenceFieldFormatter.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/entity_embed/EntityEmbedDisplay/EntityReferenceFieldFormatter.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,175 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Access\AccessResult;
+use Drupal\Core\Config\ConfigFactoryInterface;
+use Drupal\Core\Entity\ContentEntityInterface;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Field\FormatterPluginManager;
+use Drupal\Core\Language\LanguageManagerInterface;
+use Drupal\Core\Security\TrustedCallbackInterface;
+use Drupal\Core\TypedData\TypedDataManager;
+use Drupal\entity_embed\EntityEmbedDisplay\FieldFormatterEntityEmbedDisplayBase;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Entity Embed Display reusing entity reference field formatters.
+ *
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ *
+ * @EntityEmbedDisplay(
+ *   id = "entity_reference",
+ *   label = @Translation("Entity Reference"),
+ *   deriver = "Drupal\entity_embed\Plugin\Derivative\FieldFormatterDeriver",
+ *   field_type = "entity_reference",
+ *   supports_image_alt_and_title = TRUE
+ * )
+ */
+class EntityReferenceFieldFormatter extends FieldFormatterEntityEmbedDisplayBase implements TrustedCallbackInterface {
+
+  /**
+   * The configuration factory.
+   *
+   * @var \Drupal\Core\Config\ConfigFactoryInterface
+   */
+  protected $configFactory;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    $instance = parent::create($container, $configuration, $plugin_id, $plugin_definition);
+    $instance->configFactory = $container->get('config.factory');
+    return $instance;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function trustedCallbacks() {
+    return [
+      'disableContextualLinks',
+      'disableQuickEdit',
+    ];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFieldDefinition() {
+    if (!isset($this->fieldDefinition)) {
+      $this->fieldDefinition = parent::getFieldDefinition();
+      $this->fieldDefinition->setSetting('target_type', $this->getEntityTypeFromContext());
+    }
+    return $this->fieldDefinition;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFieldValue() {
+    return ['target_id' => $this->getContextValue('entity')->id()];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  protected function isApplicableFieldFormatter() {
+    $access = parent::isApplicableFieldFormatter();
+
+    // Don't bother checking if not allowed.
+    if ($access->isAllowed()) {
+      if ($this->getPluginId() === 'entity_reference:entity_reference_entity_view') {
+        // This option disables entity_reference_entity_view plugin for content
+        // entity types. If it is truthy then the plugin is enabled for all
+        // entity types.
+        $mode = $this->configFactory->get('entity_embed.settings')->get('rendered_entity_mode');
+        if ($mode) {
+          // Return *allowed* object.
+          return $access;
+        }
+
+        // Only allow this if this is not a content entity type.
+        $entity_type_id = $this->getEntityTypeFromContext();
+        if ($entity_type_id) {
+          $definition = $this->entityTypeManager->getDefinition($entity_type_id);
+          return $access->andIf(AccessResult::allowedIf(!$definition->entityClassImplements(ContentEntityInterface::class)));
+        }
+      }
+    }
+
+    return $access;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function build() {
+    $build = parent::build();
+
+    // Early return if this derived plugin is not using an EntityViewBuilder.
+    // @see \Drupal\Core\Entity\EntityViewBuilder::getBuildDefaults()
+    if (!isset($build['#view_mode'])) {
+      return $build;
+    }
+
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = $this->getEntityFromContext();
+
+    // There are a few concerns when rendering an embedded media entity:
+    // - entity access checking happens not during rendering but during routing,
+    //   and therefore we have to do it explicitly here for the embedded entity.
+    $build['#access'] = $entity->access('view', NULL, TRUE);
+    // - caching an embedded entity separately is unnecessary; the host entity
+    //   is already render cached; plus specific values may be overridden (such
+    //   as an `alt` attribute) which would mean this particular rendered
+    //   representation is unique to the host entity and hence nonsensical to
+    //   cache separately anyway.
+    unset($build['#cache']['keys']);
+    // - Contextual Links do not make sense for embedded entities; we only allow
+    //   the host entity to be contextually managed.
+    $build['#pre_render'][] = static::class . '::disableContextualLinks';
+    // - Quick Edit does not make sense for embedded entities; we only allow the
+    //   host entity to be edited in-place.
+    $build['#pre_render'][] = static::class . '::disableQuickEdit';
+    // - default styling may break captioned media embeds; attach asset library
+    //   to ensure captions behave as intended.
+    $build['#attached']['library'][] = 'entity_embed/caption';
+
+    return $build;
+  }
+
+  /**
+   * Disables Contextual Links for the embedded media by removing its property.
+   *
+   * @param array $build
+   *   The render array for the embedded media.
+   *
+   * @return array
+   *   The updated render array.
+   *
+   * @see \Drupal\Core\Entity\EntityViewBuilder::addContextualLinks()
+   */
+  public static function disableContextualLinks(array $build) {
+    unset($build['#contextual_links']);
+    return $build;
+  }
+
+  /**
+   * Disables Quick Edit for the embedded media by removing its attributes.
+   *
+   * @param array $build
+   *   The render array for the embedded media.
+   *
+   * @return array
+   *   The updated render array.
+   *
+   * @see quickedit_entity_view_alter()
+   */
+  public static function disableQuickEdit(array $build) {
+    unset($build['#attributes']['data-quickedit-entity-id']);
+    return $build;
+  }
+
+}
diff -ruN a/src/Plugin/entity_embed/EntityEmbedDisplay/FileFieldFormatter.php b/src/Plugin/entity_embed/EntityEmbedDisplay/FileFieldFormatter.php
--- a/src/Plugin/entity_embed/EntityEmbedDisplay/FileFieldFormatter.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/entity_embed/EntityEmbedDisplay/FileFieldFormatter.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,60 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Form\FormStateInterface;
+
+/**
+ * Entity Embed Display reusing file field formatters.
+ *
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ *
+ * @EntityEmbedDisplay(
+ *   id = "file",
+ *   label = @Translation("File"),
+ *   entity_types = {"file"},
+ *   deriver = "Drupal\entity_embed\Plugin\Derivative\FieldFormatterDeriver",
+ *   field_type = "file",
+ *   provider = "file"
+ * )
+ */
+class FileFieldFormatter extends EntityReferenceFieldFormatter {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFieldValue() {
+    $value = parent::getFieldValue();
+    $value += array_intersect_key($this->getConfiguration(), ['description' => '']);
+    return $value;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function defaultConfiguration() {
+    $defaults = parent::defaultConfiguration();
+    // Add support to store file description.
+    $defaults['description'] = '';
+    return $defaults;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    $form = parent::buildConfigurationForm($form, $form_state);
+
+    // Description is stored in the configuration since it doesn't map to an
+    // actual HTML attribute.
+    $form['description'] = [
+      '#type' => 'textfield',
+      '#title' => $this->t('Description'),
+      '#default_value' => $this->getConfigurationValue('description'),
+      '#description' => $this->t('The description may be used as the label of the link to the file.'),
+    ];
+
+    return $form;
+  }
+
+}
diff -ruN a/src/Plugin/entity_embed/EntityEmbedDisplay/ImageFieldFormatter.php b/src/Plugin/entity_embed/EntityEmbedDisplay/ImageFieldFormatter.php
--- a/src/Plugin/entity_embed/EntityEmbedDisplay/ImageFieldFormatter.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/entity_embed/EntityEmbedDisplay/ImageFieldFormatter.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,184 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Access\AccessResult;
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\Core\Field\FormatterPluginManager;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Image\ImageFactory;
+use Drupal\Core\Language\LanguageManagerInterface;
+use Drupal\Core\Messenger\MessengerInterface;
+use Drupal\Core\Session\AccountInterface;
+use Drupal\Core\TypedData\TypedDataManager;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Entity Embed Display reusing image field formatters.
+ *
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ *
+ * @EntityEmbedDisplay(
+ *   id = "image",
+ *   label = @Translation("Image"),
+ *   entity_types = {"file"},
+ *   deriver = "Drupal\entity_embed\Plugin\Derivative\FieldFormatterDeriver",
+ *   field_type = "image",
+ *   provider = "image"
+ * )
+ */
+class ImageFieldFormatter extends FileFieldFormatter {
+
+  /**
+   * The image factory.
+   *
+   * @var \Drupal\Core\Image\ImageFactory
+   */
+  protected $imageFactory;
+
+  /**
+   * The messenger.
+   *
+   * @var \Drupal\Core\Messenger\MessengerInterface
+   */
+  protected $messenger;
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
+    $instance = parent::create($container, $configuration, $plugin_id, $plugin_definition);
+    $instance->imageFactory = $container->get('image.factory');
+    $instance->messenger = $container->get('messenger');
+    return $instance;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFieldValue() {
+    $value = parent::getFieldValue();
+    // File field support descriptions, but images do not.
+    unset($value['description']);
+    $value += array_intersect_key($this->getAttributeValues(), ['alt' => '', 'title' => '']);
+    return $value;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function access(AccountInterface $account = NULL) {
+    return parent::access($account)->andIf($this->isValidImage());
+  }
+
+  /**
+   * Checks if the image is valid.
+   *
+   * @return \Drupal\Core\Access\AccessResult
+   *   Returns the access result.
+   */
+  protected function isValidImage() {
+    // If entity type is not file we have to return early to prevent fatal in
+    // the condition above. Access should already be forbidden at this point,
+    // which means this won't have any effect.
+    // @see EntityEmbedDisplayBase::access()
+    if ($this->getEntityTypeFromContext() != 'file') {
+      return AccessResult::forbidden();
+    }
+    $access = AccessResult::allowed();
+
+    // @todo needs cacheability metadata for getEntityFromContext.
+    // @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayBase::getEntityFromContext()
+    /** @var \Drupal\file\FileInterface $entity */
+    if ($entity = $this->getEntityFromContext()) {
+      // Loading large files is slow, make sure it is an image mime type before
+      // doing that.
+      list($type,) = explode('/', $entity->getMimeType(), 2);
+      $is_valid_image = FALSE;
+      if ($type == 'image') {
+        $is_valid_image = $this->imageFactory->get($entity->getFileUri())->isValid();
+        if (!$is_valid_image) {
+          $this->messenger->addMessage($this->t('The selected image "@image" is invalid.', ['@image' => $entity->label()]), 'error');
+        }
+      }
+      $access = AccessResult::allowedIf($type == 'image' && $is_valid_image)
+        // See the above @todo, this is the best we can do for now.
+        ->addCacheableDependency($entity);
+    }
+
+    return $access;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    $form = parent::buildConfigurationForm($form, $form_state);
+
+    // File field support descriptions, but images do not.
+    unset($form['description']);
+
+    // Ensure that the 'Link image to: Content' setting is not available.
+    if ($this->getDerivativeId() == 'image') {
+      unset($form['image_link']['#options']['content']);
+    }
+
+    $entity_element = $form_state->get('entity_element');
+    // The alt attribute is *required*, but we allow users to opt-in to empty
+    // alt attributes for the very rare edge cases where that is valid by
+    // specifying two double quotes as the alternative text in the dialog.
+    // However, that *is* stored as an empty alt attribute, so if we're editing
+    // an existing image (which means the src attribute is set) and its alt
+    // attribute is empty, then we show that as two double quotes in the dialog.
+    // @see https://www.drupal.org/node/2307647
+    // Alt attribute behavior is taken from the Core image dialog to ensure a
+    // consistent UX across various forms.
+    // @see Drupal\editor\Form\EditorImageDialog::buildForm()
+    $alt = $this->getAttributeValue('alt', '');
+    if ($alt === '') {
+      // Do not change empty alt text to two double quotes if the previously
+      // used Entity Embed Display plugin was not 'image:image'. That means that
+      // some other plugin was used so if this image formatter is selected at a
+      // later stage, then this should be treated as a new edit. We show two
+      // double quotes in place of empty alt text only if that was filled
+      // intentionally by the user.
+      if (!empty($entity_element) && $entity_element['data-entity-embed-display'] == 'image:image') {
+        $alt = MediaImageDecorator::EMPTY_STRING;
+      }
+    }
+
+    // Add support for editing the alternate and title text attributes.
+    $form['alt'] = [
+      '#type' => 'textfield',
+      '#title' => $this->t('Alternate text'),
+      '#default_value' => $alt,
+      '#description' => $this->t('This text will be used by screen readers, search engines, or when the image cannot be loaded.'),
+      '#parents' => ['attributes', 'alt'],
+      '#required' => TRUE,
+      '#required_error' => $this->t('Alternative text is required.<br />(Only in rare cases should this be left empty. To create empty alternative text, enter <code>""</code> — two double quotes without any content).'),
+      '#maxlength' => 512,
+    ];
+    $form['title'] = [
+      '#type' => 'textfield',
+      '#title' => $this->t('Title'),
+      '#default_value' => $this->getAttributeValue('title', ''),
+      '#description' => t('The title is used as a tool tip when the user hovers the mouse over the image.'),
+      '#parents' => ['attributes', 'title'],
+      '#maxlength' => 1024,
+    ];
+
+    return $form;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
+    // When the alt attribute is set to two double quotes, transform it to the
+    // empty string: two double quotes signify "empty alt attribute". See above.
+    if (trim($form_state->getValue(['attributes', 'alt'])) === MediaImageDecorator::EMPTY_STRING) {
+      $form_state->setValue(['attributes', 'alt'], '');
+    }
+  }
+
+}
diff -ruN a/src/Plugin/entity_embed/EntityEmbedDisplay/MediaImageDecorator.php b/src/Plugin/entity_embed/EntityEmbedDisplay/MediaImageDecorator.php
--- a/src/Plugin/entity_embed/EntityEmbedDisplay/MediaImageDecorator.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/entity_embed/EntityEmbedDisplay/MediaImageDecorator.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,258 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Entity\EntityInterface;
+use Drupal\Core\Form\FormStateInterface;
+use Drupal\Core\Session\AccountInterface;
+use Drupal\Core\StringTranslation\StringTranslationTrait;
+use Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface;
+use Drupal\image\Plugin\Field\FieldType\ImageItem;
+use Drupal\media\MediaInterface;
+
+/**
+ * Decorator on all EntityEmbedDisplays that adds alt and title overriding.
+ */
+class MediaImageDecorator implements EntityEmbedDisplayInterface {
+
+  use StringTranslationTrait;
+
+  /**
+   * A string that signifies not to render the alt text.
+   *
+   * @const string
+   */
+  const EMPTY_STRING = '""';
+
+  /**
+   * The decorated EntityEmbedDisplay class.
+   *
+   * @var \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+   */
+  private $decorated;
+
+  /**
+   * MediaImageDecorator constructor.
+   *
+   * @param \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface $decorated
+   *   The decorated EntityEmbedDisplay plugin.
+   */
+  public function __construct(EntityEmbedDisplayInterface $decorated) {
+    $this->decorated = $decorated;
+  }
+
+  /**
+   * Passes through all unknown calls to the decorated object.
+   */
+  public function __call($method, $args) {
+    return call_user_func_array([$this->decorated, $method], $args);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function access(AccountInterface $account = NULL) {
+    return $this->decorated->access($account);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function validateConfigurationForm(array &$form, FormStateInterface $form_state) {
+    return $this->decorated->validateConfigurationForm($form, $form_state);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function defaultConfiguration() {
+    return $this->decorated->defaultConfiguration();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function calculateDependencies() {
+    return $this->decorated->calculateDependencies();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getConfiguration() {
+    return $this->decorated->getConfiguration();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getPluginDefinition() {
+    return $this->decorated->getPluginDefinition();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getPluginId() {
+    return $this->decorated->getPluginId();
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function setConfiguration(array $configuration) {
+    return $this->decorated->setConfiguration($configuration);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    $form = $this->decorated->buildConfigurationForm($form, $form_state);
+
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = $this->decorated->getEntityFromContext();
+
+    if ($image_field = $this->getMediaImageSourceField($entity)) {
+
+      $settings = $entity->{$image_field}->getItemDefinition()->getSettings();
+      $attributes = $this->getAttributeValues();
+
+      $alt = isset($attributes['alt']) ? $attributes['alt'] : NULL;
+      $title = isset($attributes['title']) ? $attributes['title'] : NULL;
+
+      // Setting empty alt to double quotes. See ImageFieldFormatter.
+      if ($settings['alt_field_required'] && $alt === '') {
+        $alt = static::EMPTY_STRING;
+      }
+
+      if (!empty($settings['alt_field'])) {
+        // Add support for editing the alternate and title text attributes.
+        $form['alt'] = [
+          '#type' => 'textfield',
+          '#title' => $this->t('Alternate text'),
+          '#default_value' => $alt,
+          '#description' => $this->t('This text will be used by screen readers, search engines, or when the image cannot be loaded.'),
+          '#required_error' => $this->t('Alternative text is required.<br />(Only in rare cases should this be left empty. To create empty alternative text, enter <code>""</code> — two double quotes without any content).'),
+          '#maxlength' => 512,
+          '#placeholder' => $entity->{$image_field}->alt,
+        ];
+      }
+
+      if (!empty($settings['title_field'])) {
+        $form['title'] = [
+          '#type' => 'textfield',
+          '#title' => $this->t('Title'),
+          '#default_value' => $title,
+          '#description' => t('The title is used as a tool tip when the user hovers the mouse over the image.'),
+          '#maxlength' => 1024,
+          '#placeholder' => $entity->{$image_field}->title,
+        ];
+      }
+    }
+
+    return $form;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = $this->decorated->getEntityFromContext();
+    if ($image_field = $this->getMediaImageSourceField($entity)) {
+      $settings = $entity->{$image_field}->getItemDefinition()->getSettings();
+      $values = $form_state->getValue(['attributes', 'data-entity-embed-display-settings']);
+
+      if (!empty($settings['alt_field'])) {
+        // When the alt attribute is set to two double quotes, transform it to
+        // the empty string: two double quotes signify "empty alt attribute".
+        // See ImagefieldFormatter.
+        if (trim($values['alt']) === static::EMPTY_STRING) {
+          $values['alt'] = static::EMPTY_STRING;
+        }
+        // If the alt text is unchanged from the values set on the
+        // field, there's no need for the alt property to be set.
+        elseif ($values['alt'] === $entity->{$image_field}->alt) {
+          $values['alt'] = '';
+        }
+
+        $form_state->setValue(['attributes', 'alt'], $values['alt']);
+        $form_state->unsetValue([
+          'attributes',
+          'data-entity-embed-display-settings',
+          'alt',
+        ]);
+      }
+
+      if (!empty($settings['title_field'])) {
+        if (empty($values['title'])) {
+          $values['title'] = '';
+        }
+        // If the title text is unchanged from the values set on the
+        // field, there's no need for the title property to be set.
+        elseif ($values['title'] === $entity->{$image_field}->title) {
+          $values['title'] = '';
+        }
+
+        $form_state->setValue(['attributes', 'title'], $values['title']);
+        $form_state->unsetValue([
+          'attributes',
+          'data-entity-embed-display-settings',
+          'title',
+        ]);
+      }
+    }
+    $this->decorated->submitConfigurationForm($form, $form_state);
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function build() {
+    $build = $this->decorated->build();
+
+    /** @var \Drupal\Core\Entity\EntityInterface $entity */
+    $entity = $this->decorated->getEntityFromContext();
+
+    if ($image_field = $this->getMediaImageSourceField($entity)) {
+      $settings = $entity->{$image_field}->getItemDefinition()->getSettings();
+
+      if (!empty($settings['alt_field']) && $this->hasAttribute('alt')) {
+        $entity->{$image_field}->alt = $this->getAttributeValue('alt');
+        $entity->thumbnail->alt = $this->getAttributeValue('alt');
+      }
+
+      if (!empty($settings['title_field']) && $this->hasAttribute('title')) {
+        $entity->{$image_field}->title = $this->getAttributeValue('title');
+        $entity->thumbnail->title = $this->getAttributeValue('title');
+      }
+    }
+
+    return $build;
+  }
+
+  /**
+   * Get image field from source config.
+   *
+   * @param \Drupal\Core\Entity\EntityInterface $entity
+   *   Embedded entity.
+   *
+   * @return string|null
+   *   String of image field name.
+   */
+  protected function getMediaImageSourceField(EntityInterface $entity) {
+    if (!$entity instanceof MediaInterface) {
+      return NULL;
+    }
+
+    $field_definition = $entity->getSource()
+      ->getSourceFieldDefinition($entity->bundle->entity);
+    $item_class = $field_definition->getItemDefinition()->getClass();
+    if ($item_class == ImageItem::class || is_subclass_of($item_class, ImageItem::class)) {
+      return $field_definition->getName();
+    }
+    return NULL;
+  }
+
+}
diff -ruN a/src/Plugin/entity_embed/EntityEmbedDisplay/ViewModeFieldFormatter.php b/src/Plugin/entity_embed/EntityEmbedDisplay/ViewModeFieldFormatter.php
--- a/src/Plugin/entity_embed/EntityEmbedDisplay/ViewModeFieldFormatter.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Plugin/entity_embed/EntityEmbedDisplay/ViewModeFieldFormatter.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,86 @@
+<?php
+
+namespace Drupal\entity_embed\Plugin\entity_embed\EntityEmbedDisplay;
+
+use Drupal\Core\Form\FormStateInterface;
+
+/**
+ * Entity Embed Display reusing entity reference field formatters.
+ *
+ * @see \Drupal\entity_embed\EntityEmbedDisplay\EntityEmbedDisplayInterface
+ *
+ * @EntityEmbedDisplay(
+ *   id = "view_mode",
+ *   label = @Translation("View Mode"),
+ *   deriver = "Drupal\entity_embed\Plugin\Derivative\ViewModeDeriver",
+ *   field_type = "entity_reference"
+ * )
+ */
+class ViewModeFieldFormatter extends EntityReferenceFieldFormatter {
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFieldFormatter() {
+    if (!isset($this->fieldFormatter)) {
+      $display = [
+        'type' => $this->getFieldFormatterId(),
+        'settings' => [
+          'view_mode' => $this->getPluginDefinition()['view_mode'],
+        ],
+        'label' => 'hidden',
+      ];
+
+      // Create the formatter plugin. Will use the default formatter for that
+      // field type if none is passed.
+      $this->fieldFormatter = $this->formatterPluginManager->getInstance(
+        [
+          'field_definition' => $this->getFieldDefinition(),
+          'view_mode' => '_entity_embed',
+          'configuration' => $display,
+        ]
+      );
+    }
+    return $this->fieldFormatter;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {
+    // Configuration form is not needed as the view mode is defined implicitly.
+    return [];
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFieldFormatterId() {
+    return 'entity_reference_entity_view';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function calculateDependencies() {
+    $definition = $this->getPluginDefinition();
+    $view_mode = $definition['view_mode'];
+
+    $view_modes = [];
+
+    foreach ($definition['entity_types'] as $type) {
+      $view_modes[] = "$type.$view_mode";
+    }
+
+    $entity_view_modes = $this->entityTypeManager
+      ->getStorage('entity_view_mode')
+      ->loadMultiple($view_modes);
+
+    foreach ($entity_view_modes as $view_mode) {
+      $this->addDependency($view_mode->getConfigDependencyKey(), $view_mode->getConfigDependencyName());
+    }
+
+    return $this->dependencies;
+  }
+
+}
diff -ruN a/src/Twig/EntityEmbedTwigExtension.php b/src/Twig/EntityEmbedTwigExtension.php
--- a/src/Twig/EntityEmbedTwigExtension.php	1970-01-01 01:00:00.000000000 +0100
+++ b/src/Twig/EntityEmbedTwigExtension.php	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,94 @@
+<?php
+
+namespace Drupal\entity_embed\Twig;
+
+use Drupal\Core\Entity\EntityTypeManagerInterface;
+use Drupal\entity_embed\EntityEmbedBuilderInterface;
+use Symfony\Component\DependencyInjection\ContainerInterface;
+
+/**
+ * Provide entity embedding function within Twig templates.
+ */
+class EntityEmbedTwigExtension extends \Twig_Extension {
+
+  /**
+   * The entity type manager service.
+   *
+   * @var \Drupal\Core\Entity\EntityTypeManagerInterface
+   */
+  protected $entityTypeManager;
+
+  /**
+   * The entity embed builder service.
+   *
+   * @var \Drupal\entity_embed\EntityEmbedBuilderInterface
+   */
+  protected $builder;
+
+  /**
+   * Constructs a new EntityEmbedTwigExtension.
+   *
+   * @param \Drupal\Core\Entity\EntityTypeManagerInterface $entity_type_manager
+   *   The entity type manager service.
+   * @param \Drupal\entity_embed\EntityEmbedBuilderInterface $builder
+   *   The Entity embed builder service.
+   */
+  public function __construct(EntityTypeManagerInterface $entity_type_manager, EntityEmbedBuilderInterface $builder) {
+    $this->entityTypeManager = $entity_type_manager;
+    $this->builder = $builder;
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public static function create(ContainerInterface $container) {
+    return new static(
+      $container->get('entity_type.manager'),
+      $container->get('entity_embed.builder')
+    );
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getName() {
+    return 'entity_embed.twig.entity_embed_twig_extension';
+  }
+
+  /**
+   * {@inheritdoc}
+   */
+  public function getFunctions() {
+    return [
+      new \Twig_SimpleFunction('entity_embed', [$this, 'getRenderArray']),
+    ];
+  }
+
+  /**
+   * Return the render array for an entity.
+   *
+   * @param string $entity_type
+   *   The machine name of an entity_type like 'node'.
+   * @param string $entity_id
+   *   The entity ID.
+   * @param string $display_plugin
+   *   (optional) The Entity Embed Display plugin to be used to render the
+   *   entity.
+   * @param array $display_settings
+   *   (optional) A list of settings for the Entity Embed Display plugin.
+   *
+   * @return array
+   *   A render array from entity_view().
+   */
+  public function getRenderArray($entity_type, $entity_id, $display_plugin = 'default', array $display_settings = []) {
+    $entity = $this->entityTypeManager->getStorage($entity_type)->load($entity_id);
+    $context = [
+      'data-entity-type' => $entity_type,
+      'data-entity-uuid' => $entity->uuid(),
+      'data-entity-embed-display' => $display_plugin,
+      'data-entity-embed-display-settings' => $display_settings,
+    ];
+    return $this->builder->buildEntityEmbed($entity, $context);
+  }
+
+}
diff -ruN a/templates/entity-embed-container.html.twig b/templates/entity-embed-container.html.twig
--- a/templates/entity-embed-container.html.twig	1970-01-01 01:00:00.000000000 +0100
+++ b/templates/entity-embed-container.html.twig	2022-10-20 16:16:12.000000000 +0200
@@ -0,0 +1,15 @@
+{#
+/**
+ * @file
+ * Default theme implementation of a container used to wrap embedded entities.
+ *
+ * Available variables:
+ * - attributes: HTML attributes for the containing element.
+ * - children: The rendered child elements of the container.
+ *
+ * @see template_preprocess_entity_embed_container()
+ *
+ * @ingroup themeable
+ */
+#}
+<div{{ attributes }}>{{ children }}</div>
diff -ruN a/webpack.config.js b/webpack.config.js
--- a/webpack.config.js	1970-01-01 01:00:00.000000000 +0100
+++ b/webpack.config.js	2023-06-08 22:55:01.000000000 +0200
@@ -0,0 +1,65 @@
+const path = require('path');
+const fs = require('fs');
+const webpack = require('webpack');
+const TerserPlugin = require('terser-webpack-plugin');
+
+function getDirectories(srcpath) {
+  return fs
+    .readdirSync(srcpath)
+    .filter((item) => fs.statSync(path.join(srcpath, item)).isDirectory());
+}
+
+module.exports = [];
+// Loop through every subdirectory in src, each a different plugin, and build
+// each one in ./build.
+getDirectories('./js/ckeditor5_plugins').forEach((dir) => {
+  const bc = {
+    mode: 'production',
+    optimization: {
+      minimize: true,
+      minimizer: [
+        new TerserPlugin({
+          terserOptions: {
+            format: {
+              comments: false,
+            },
+          },
+          test: /\.js(\?.*)?$/i,
+          extractComments: false,
+        }),
+      ],
+      moduleIds: 'named',
+    },
+    entry: {
+      path: path.resolve(
+        __dirname,
+        'js/ckeditor5_plugins',
+        dir,
+        'src/index.js',
+      ),
+    },
+    output: {
+      path: path.resolve(__dirname, './js/build'),
+      filename: `${dir}.js`,
+      library: ['CKEditor5', dir],
+      libraryTarget: 'umd',
+      libraryExport: 'default',
+    },
+    plugins: [
+      // It is possible to require the ckeditor5-dll.manifest.json used in
+      // core/node_modules rather than having to install CKEditor 5 here.
+      // However, that requires knowing the location of that file relative to
+      // where your module code is located.
+      new webpack.DllReferencePlugin({
+        manifest: require('./node_modules/ckeditor5/build/ckeditor5-dll.manifest.json'), // eslint-disable-line global-require, import/no-unresolved
+        scope: 'ckeditor5/src',
+        name: 'CKEditor5.dll',
+      }),
+    ],
+    module: {
+      rules: [{ test: /\.svg$/, use: 'raw-loader' }],
+    },
+  };
+
+  module.exports.push(bc);
+});
